<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.docbook.org/xml/4.3/docbookx.dtd">
<!-- section history:
  2007-06-14 alex falappa: finished italian translation
  2007-04-13 alex falappa: started it translation
  2008-03-12 jpl : french update
-->
<sect1 xmlns:xi="http://www.w3.org/2001/XInclude" id="gimp-using-script-fu-tutorial">
  <title>
    <phrase>A Script-Fu Tutorial</phrase>
  </title>
  <indexterm>
    <primary>Script-Fu</primary>
    <secondary>Tutorial</secondary>
  </indexterm>
  <para>
    In this training course, we'll introduce you to the fundamentals of Scheme
    necessary to use Script-Fu, and then build a handy script that you can add
    to your toolbox of scripts. The script prompts the user for some text,
    then creates a new image sized perfectly to the text. We will then enhance
    the script to allow for a buffer of space around the text. We will
    conclude with a few suggestions for ways to ramp up your knowledge of
    Script-Fu.
  </para>
  <note>
    <para>
      This section as adapted from a tutorial written for the GIMP 1 User
      Manual by Mike Terry.
    </para>
  </note>
  <sect2 id="gimp-using-script-fu-tutorial-scheme">
    <title>
      <phrase>Getting Acquainted With Scheme</phrase>
    </title>
    <sect3>
      <title>
        <phrase>Let's Start Scheme'ing</phrase>
      </title>
      <para>The first thing to learn is that:</para>
      <para>
        <emphasis>
          Every statement in Scheme is surrounded by parentheses ().
        </emphasis>
      </para>
      <para>The second thing you need to know is that:</para>
      <para>
        <emphasis>
          The function name/operator is always the first item in the
          parentheses, and the rest of the items are parameters to the
          function.
        </emphasis>
      </para>
      <para>
        However, not everything enclosed in parentheses is a function -- they
        can also be items in a list -- but we'll get to that later. This
        notation is referred to as prefix notation, because the function
        prefixes everything else. If you're familiar with postfix notation, or
        own a calculator that uses Reverse Polish Notation (such as most HP
        calculators), you should have no problem adapting to formulating
        expressions in Scheme.
      </para>
      <para>The third thing to understand is that:</para>
      <para>
        <emphasis>
          Mathematical operators are also considered functions, and thus are
          listed first when writing mathematical expressions.
        </emphasis>
      </para>
      <para>
        This follows logically from the prefix notation that we just
        mentioned.
      </para>
    </sect3>
    <sect3>
      <title>
        <phrase>
          Examples Of Prefix, Infix, And Postfix Notations
        </phrase>
      </title>
      <para>
        Here are some quick examples illustrating the differences between
        <emphasis>prefix</emphasis>, <emphasis>infix</emphasis>, and
        <emphasis>postfix</emphasis> notations. We'll add a 1 and 3 together:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Prefix notation: + 1 3 (the way Scheme will want it)
          </para>
        </listitem>
        <listitem>
          <para>
            Infix notation: 1 + 3 (the way we "normally" write it)
          </para>
        </listitem>
        <listitem>
          <para>
            Postfix notation: 1 3 + (the way many HP calculators will want it)
          </para>
        </listitem>
      </itemizedlist>
    </sect3>
    <sect3>
      <title>
        <phrase>Practicing In Scheme</phrase>
      </title>
      <para>
        Now, let's practice what we have just learned. Start up GIMP,
        if you have not already done so, and choose <menuchoice><guimenu>Xtns</guimenu><guisubmenu>Script-Fu</guisubmenu><guimenuitem>Console</guimenuitem></menuchoice>. This will start
        up the Script-Fu Console window, which allows us to work
        interactively in Scheme. In a matter of moments, the Script-Fu
        Console will appear:
      </para>
    </sect3>
    <sect3 id="gimp-using-script-fu-tutorial-console">
      <title>
        <phrase>The Script-Fu Console Window</phrase>
      </title>
      <para>
        At the bottom of this window is an entry-field entitled
        <guilabel>Current Command</guilabel>.
        Here, we can test out simple Scheme commands interactively. Let's
        start out easy, and add some numbers:
      </para>
      <programlisting>(+ 3 5)</programlisting>
      <para>
        Typing this in and hitting <keycap>Enter</keycap>
        yields the expected answer of 8 in the center window.
      </para>
      <figure>
        <title>
          <phrase>
            Use Script-Fu Console.
          </phrase>
        </title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/using/script-fu-console.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
        Now, what if we wanted to add more than one number? The <quote>+</quote>
        function can take two or more arguments, so this is not a problem:
      </para>
      <programlisting>(+ 3 5 6)</programlisting>
      <para>This also yields the expected answer of 14.</para>
      <para>
        So far, so good -- we type in a Scheme statement and it's executed
        immediately in the Script-Fu Console window. Now for a word of
        caution....
      </para>
    </sect3>
    <sect3>
      <title>
        <phrase>Watch Out For Extra Parentheses</phrase>
      </title>
      <para>
        If you're like me, you're used to being able to use extra parentheses
        whenever you want to -- like when you're typing a complex mathematical
        equation and you want to separate the parts by parentheses to make it
        clearer when you read it. In Scheme, you have to be careful and not
        insert these extra parentheses incorrectly. For example, say we wanted
        to add 3 to the result of adding 5 and 6 together:
      </para>
      <programlisting>3 + (5 + 6) + 7 = ?</programlisting>
      <para>
        Knowing that the + operator can take a list of numbers to add, you
        might be tempted to convert the above to the following:
      </para>
      <programlisting>(+ 3 (5 6) 7)</programlisting>
      <para>
        However, this is incorrect -- remember, every statement in Scheme
        starts and ends with parens, so the Scheme interpreter will think that
        you're trying to call a function named <quote>5</quote> in the second
        group of parens, rather than summing those numbers before adding them
        to 3.
      </para>
      <para>
        The correct way to write the above statement would be:
      </para>
      <programlisting>(+ 3 (+ 5 6) 7)</programlisting>
    </sect3>
    <sect3>
      <title>
        <phrase>Make Sure You Have The Proper Spacing, Too</phrase>
      </title>
      <para>
        If you are familiar with other programming languages, like C/C++, Perl
        or Java, you know that you don't need white space around mathematical
        operators to properly form an expression:
      </para>
      <programlisting>
        <literal>3+5, 3 +5, 3+ 5</literal>
      </programlisting>
      <para>
        These are all accepted by C/C++, Perl and Java compilers. However, the
        same is not true for Scheme. You must have a space after a
        mathematical operator (or any other function name or operator) in
        Scheme for it to be correctly interpreted by the Scheme interpreter.
      </para>
      <para>
        Practice a bit with simple mathematical equations in the Script-Fu
        Console until you're totally comfortable with these initial concepts.
      </para>
    </sect3>
  </sect2>
  <sect2 id="gimp-using-script-fu-tutorial-identifier">
    <title>
      <phrase>Variables And Functions</phrase>
    </title>
    <para>
      Now that we know that every Scheme statement is enclosed in parentheses,
      and that the function name/operator is listed first, we need to know how
      to create and use variables, and how to create and use functions. We'll
      start with the variables.
    </para>
    <sect3>
      <title>
        <phrase>Declaring Variables</phrase>
      </title>
      <para>
        Although there are a couple of different methods for declaring
        variables, the preferred method is to use the let* construct. If
        you're familiar with other programming languages, this construct is
        equivalent to defining a list of local variables and a scope in which
        they're active. As an example, to declare two variables, a and b,
        initialized to 1 and 2, respectively, you'd write:
      </para>
      <programlisting>
        (let*
           (
              (a 1)
              (b 2)
           )
           (+ a b)
        )
      </programlisting>
      <para>or, as one line:</para>
      <programlisting>(let* ( (a 1) (b 2) ) (+ a b) )</programlisting>
      <note>
        <para>
          You'll have to put all of this on one line if you're using the
          console window. In general, however, you'll want to adopt a similar
          practice of indentation to help make your scripts more readable.
          We'll talk a bit more about this in the section on White Space.
        </para>
      </note>
      <para>
        This declares two local variables, a and b, initializes them, then
        prints the sum of the two variables.
      </para>
    </sect3>
    <sect3>
      <title>
        <phrase>What Is A Local Variable?</phrase>
      </title>
      <para>
        You'll notice that we wrote the summation <code>(+ a b)</code> within
        the parens of the <code>let*</code> expression, not after it.
      </para>
      <para>
        This is because the <code>let*</code>
        statement defines an area in your script in which the declared
        variables are usable; if you type the (+ a b) statement after the
        (let* ...) statement, you'll get an error, because the declared
        variables are only valid within the context of the <code>let*</code>
        statement; they are what programmers call local variables.
      </para>
    </sect3>
    <sect3>
      <title>
        <phrase>The General Syntax Of <code>let*</code></phrase>
      </title>
      <para>
        The general form of a <code>let*</code> statement is:
      </para>
      <programlisting>
        (let* ( <replaceable>variables</replaceable> )
          <replaceable>expressions</replaceable> )
      </programlisting>
      <para>
        where variables are declared within parens, e.g., (a 2), and
        expressions are any valid Scheme expressions. Remember that the
        variables declared here are only valid within the
        <code>let*</code> statement -- they're local variables.
      </para>
    </sect3>
    <sect3>
      <title>
        <phrase>White Space</phrase>
      </title>
      <para>
        Previously, we mentioned the fact that you'll probably want to use
        indentation to help clarify and organize your scripts. This is a good
        policy to adopt, and is not a problem in Scheme -- white space is
        ignored by the Scheme interpreter, and can thus be liberally applied
        to help clarify and organize the code within a script. However, if
        you're working in Script-Fu's Console window, you'll have to enter an
        entire expression on one line; that is, everything between the opening
        and closing parens of an expression must come on one line in the
        Script-Fu Console window.
      </para>
    </sect3>
    <sect3>
      <title>
        <phrase>Assigning A New Value To A Variable</phrase>
      </title>
      <para>
        Once you've initialized a variable, you might need to change its value
        later on in the script. Use the set! statement to change the
        variable's value:
      </para>
      <programlisting>
        (let* ( (theNum 10) ) (set! theNum (+ theNum theNum)) )
      </programlisting>
      <para>
        Try to guess what the above statement will do, then go ahead and enter
        it in the Script-Fu Console window.
      </para>
      <note>
        <para>
          The <quote>\</quote> indicates that there is no line break. Ignore it (don't type
          it in your Script-Fu console and don't hit Enter), just continue
          with the next line.
        </para>
      </note>
    </sect3>
    <sect3>
      <title>
        <phrase>Functions</phrase>
      </title>
      <para>
        Now that you've got the hang of variables, let's get to work with some
        functions. You declare a function with the following syntax:
      </para>
      <programlisting>
        (define
           (
              <replaceable>name</replaceable>
              <replaceable>param-list</replaceable>
           )
           <replaceable>expressions</replaceable>
        )
      </programlisting>
      <para>
        where <replaceable>name</replaceable> is the name assigned to this
        function, <replaceable>param-list</replaceable> is a space-delimited
        list of parameter names, and <replaceable>expressions</replaceable>
        is a series of expressions that the function executes when it's
        called. For example:
      </para>
      <programlisting>(define (AddXY inX inY) (+ inX inY) )</programlisting>
      <para><varname>AddXY</varname> is the function's name and
        <varname>inX</varname> and <varname>inY</varname>
        are the variables. This function takes its two parameters and adds
        them together.
      </para>
      <para>
        If you've programmed in other imperative languages (like C/C++, Java,
        Pascal, etc.), you might notice that a couple of things are absent in
        this function definition when compared to other programming languages.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            First, notice that the parameters don't have any "types" (that is,
            we didn't declare them as strings, or integers, etc.). Scheme is a
            type-less language. This is handy and allows for quicker script
            writing.
          </para>
        </listitem>
        <listitem>
          <para>
            Second, notice that we don't need to worry about how to "return"
            the result of our function -- the last statement is the value
            "returned" when calling this function. Type the function into the
            console, then try something like:
          </para>
          <programlisting>(AddXY (AddXY 5 6) 4)</programlisting>
        </listitem>
      </itemizedlist>
    </sect3>
  </sect2>
  <sect2 id="gimp-using-script-fu-tutorial-lists">
    <title>
      <phrase>Lists, Lists And More Lists</phrase>
    </title>
    <para>
      We've trained you in variables and functions, and now enter the
      murky swamps of Scheme's lists.
    </para>
    <sect3>
      <title>
        <phrase>Defining A List</phrase>
      </title>
      <para>
        Before we talk more about lists, it is necessary that you know
        the difference between atomic values and lists.
      </para>
      <para>
        You've already seen atomic values when we initialized
        variables in the previous lesson. An atomic value is a single
        value. So, for example, we can assign the variable "x" the
        single value of 8 in the following statement:
      </para>
      <programlisting>(let* ( (x 8) ) x)</programlisting>
      <para>
        (We added the expression <varname>x</varname> at the end to print out
        the value assigned to <varname>x</varname>-- normally you won't need
        to do this. Notice how <code>let*</code> operates just like a
        function: The value of the last statement is the value returned.)
      </para>
      <para>
        A variable may also refer to a list of values, rather than a
        single value. To assign the variable <varname>x</varname> the
        list of values 1, 3, 5, we'd type:
      </para>
      <programlisting>(let* ( (x '(1 3 5))) x)</programlisting>
      <para>
        Try typing both statements into the Script-Fu Console and
        notice how it replies. When you type the first statement in,
        it simply replies with the result:
      </para>
      <programlisting>8</programlisting>
      <para>
        However, when you type in the other statement, it replies with
        the following result:
      </para>
      <programlisting>(1 3 5)</programlisting>
      <para>
        When it replies with the value 8 it is informing you that
        <varname>x</varname> contains the atomic value 8. However,
        when it replies with (1 3 5), it is then informing you that
        <varname>x</varname> contains not a single value, but a list
        of values. Notice that there are no commas in our declaration
        or assignment of the list, nor in the printed result.
      </para>
      <para>The syntax to define a list is:</para>
      <programlisting>'(a b c)</programlisting>
      <para>
        where <varname>a</varname>, <varname>b</varname>, and
        <varname>c</varname> are literals. We use the apostrophe (')
        to indicate that what follows in the parentheses is a list of
        literal values, rather than a function or expression.
      </para>
      <para>An empty list can be defined as such:</para>
      <programlisting>'()</programlisting>
      <para>or simply:</para>
      <programlisting>()</programlisting>
      <para>
        Lists can contain atomic values, as well as other lists:
      </para>
      <programlisting>
(let*
   (
        (x
           '("GIMP" (1 2 3) ("is" ("great" () ) ) )
        )
    )
    x
)
      </programlisting>
      <para>
        Notice that after the first apostrophe, you no longer need to use an
        apostrophe when defining the inner lists. Go ahead and copy the
        statement into the Script-Fu Console and see what it returns.
      </para>
      <para>
        You should notice that the result returned is not a list of
        single, atomic values; rather, it is a list of a literal
        <code>("The GIMP")</code>, the list <code>(1 2 3)</code>, etc.
      </para>
    </sect3>
    <sect3>
      <title>
        <phrase>How To Think Of Lists</phrase>
      </title>
      <para>
        It's useful to think of lists as composed of a <quote>head</quote> and a
        <quote>tail</quote>.
        The head is the first element of the list, the tail the rest of the
        list. You'll see why this is important when we discuss how to add to
        lists and how to access elements in the list.
      </para>
    </sect3>
    <sect3>
      <title>
        <phrase>
          Creating Lists Through Concatenation (The Cons Function)
        </phrase>
      </title>
      <para>
        One of the more common functions you'll encounter is the cons
        function. It takes a value and places it to its second argument, a
        list. From the previous section, I suggested that you think of a list
        as being composed of an element (the head) and the remainder of the
        list (the tail). This is exactly how cons functions -- it adds an
        element to the head of a list. Thus, you could create a list as
        follows:
      </para>
      <programlisting>(cons 1 '(2 3 4) )</programlisting>
      <para>The result is the list <code>(1 2 3 4)</code>.</para>
      <para>You could also create a list with one element:</para>
      <programlisting>(cons 1 () )</programlisting>
      <para>
        You can use previously declared variables in place of any literals, as
        you would expect.
      </para>
    </sect3>
    <sect3>
      <title>
        <phrase>
          Defining A List Using The <code>list</code> Function
        </phrase>
      </title>
      <para>
        To define a list composed of literals or previously declared
        variables, use the list function:
      </para>
      <programlisting>(list 5 4 3 a b c)</programlisting>
      <para>
        This will compose and return a list containing the values held
        by the variables <varname>a</varname>, <varname>b</varname>
        and <varname>c</varname>. For example:
      </para>
      <programlisting>
        (let*  (
                  (a 1)
                  (b 2)
                  (c 3)
               )

               (list 5 4 3 a b c)
        )
      </programlisting>
      <para>
        This code creates the list <code>(5 4 3 1 2 3)</code>.
      </para>
    </sect3>
    <sect3>
      <title>
        <phrase>Accessing Values In A List</phrase>
      </title>
      <para>
        To access the values in a list, use the functions
        <code>car</code> and <code>cdr</code>,
        which return the first element of the list and the rest of the list,
        respectively. These functions break the list down into the head::tail
        construct I mentioned earlier.
      </para>
    </sect3>
    <sect3>
      <title>
        <phrase>The <code>car</code> Function</phrase>
      </title>
      <para><code>car</code> returns the first element of the list (the
        head of the list). The list needs to be non-null. Thus, the
        following returns the first element of the list:
      </para>
      <programlisting>(car '("first" 2 "third"))</programlisting>
      <para>which is:</para>
      <programlisting>"first"</programlisting>
    </sect3>
    <sect3>
      <title>
        <phrase>The <code>cdr</code> function</phrase>
      </title>
      <para><code>cdr</code> returns the rest of the list after the first element
        (the tail of the list). If there is only one element in the list, it
        returns an empty list.
      </para>
      <programlisting>(cdr '("first" 2 "third"))</programlisting>
      <para>returns:</para>
      <programlisting>(2 "third")</programlisting>
      <para>whereas the following:</para>
      <programlisting>(cdr '("one and only"))</programlisting>
      <para>returns:</para>
      <programlisting>()</programlisting>
    </sect3>
    <sect3>
      <title>
        <phrase>Accessing Other Elements In A List</phrase>
      </title>
      <para>
        OK, great, we can get the first element in a list, as well as
        the rest of the list, but how do we access the second, third
        or other elements of a list? There exist several "convenience"
        functions to access, for example, the head of the head of the
        tail of a list (<code>caadr</code>), the tail of the tail of a
        list (<code>cddr</code>), etc.
      </para>
      <para>
        The basic naming convention is easy: The a's and d's represent
        the heads and tails of lists, so
      </para>
      <programlisting>(car (cdr (car x) ) )</programlisting>
      <para>could be written as:</para>
      <programlisting>(cadar x)</programlisting>
      <para>
        To get some practice with list-accessing functions, try typing in the
        following (except all on one line if you're using the console); use
        different variations of car and cdr to access the different elements
        of the list:
      </para>
      <programlisting>
        (let* (
                 (x  '( (1 2 (3 4 5) 6)  7  8  (9 10) )
                 )
              )
              ; place your car/cdr code here
        )
      </programlisting>
      <para>
        Try accessing the number 3 in the list using only two function
        calls. If you can do that, you're on your way to becoming a
        Script-Fu Master!
      </para>
      <note>
        <para>
          In Scheme, a semicolon (";") marks a comment.  It, and
          anything that follows it on the same line, are ignored by the
          script interpreter, so you can use this to add comments to jog
          your memory when you look at the script later.
        </para>
      </note>
    </sect3>
  </sect2>
  <sect2 id="gimp-using-script-fu-tutorial-first-script">
    <title>
      <phrase>Your First Script-Fu Script</phrase>
    </title>
    <para>
      Do you not need to stop and catch your breath? No? Well then,
      let's proceed with your fourth lesson -- your first Script-Fu
      Script.
    </para>
    <sect3>
      <title>
        <phrase>Creating A Text Box Script</phrase>
      </title>
      <para>
        One of the most common operations I perform in GIMP is
        creating a box with some text in it for a web page, a logo or
        whatever. However, you never quite know how big to make the
        initial image when you start out. You don't know how much
        space the text will fill with the font and font size you
        want.
      </para>
      <para>
        The Script-Fu Master (and student) will quickly realize that
        this problem can easily be solved and automated with
        Script-Fu.
      </para>
      <para>
        We will, therefore, create a script, called Text Box, which
        creates an image correctly sized to fit snugly around a line
        of text the user inputs. We'll also let the user choose the
        font, font size and text color.
      </para>
    </sect3>
    <sect3>
      <title>
        <phrase>Editing And Storing Your Scripts</phrase>
      </title>
      <para>
        Up until now, we've been working in the Script-Fu Console. Now,
        however, we're going to switch to editing script text files.
      </para>
      <para>
        Where you place your scripts is a matter of preference -- if you have
        access to GIMP's default script directory, you can place your scripts
        there. However, I prefer keeping my personal scripts in my own script
        directory, to keep them separate from the factory-installed scripts.
      </para>
      <para>
        In the <filename>.gimp-2.4</filename> directory that GIMP made
        off of your home directory, you should find a directory called
        <filename>scripts</filename>. GIMP will automatically look in
        your <filename>.gimp-2.4</filename> directory for a scripts
        directory, and add the
        scripts in this directory to the Script-Fu database. You
        should place your personal scripts here.
      </para>
    </sect3>
    <sect3>
      <title>
        <phrase>The Bare Essentials</phrase>
      </title>
      <para>
        Every Script-Fu script defines at least one function, which is the
        script's main function. This is where you do the work.
      </para>
      <para>
        Every script must also register with the procedural database, so you
        can access it within GIMP.
      </para>
      <para>We'll define the main function first:</para>
      <programlisting>
        (define (script-fu-text-box inText inFont inFontSize inTextColor))
      </programlisting>
      <para>
        Here, we've defined a new function called script-fu-text-box that
        takes four parameters, which will later correspond to some text, a
        font, the font size, and the text's color. The function is currently
        empty and thus does nothing. So far, so good -- nothing new, nothing
        fancy.
      </para>
    </sect3>
    <sect3>
      <title>
        <phrase>Naming Conventions</phrase>
      </title>
      <para>
        Scheme's naming conventions seem to prefer lowercase letters with
        hyphens, which I've followed in the naming of the function. However,
        I've departed from the convention with the parameters. I like more
        descriptive names for my parameters and variables, and thus add the
        "in" prefix to the parameters so I can quickly see that they're values
        passed into the script, rather than created within it. I use the
        prefix "the" for variables defined within the script.
      </para>
      <para>
        It's GIMP convention to name your script functions script-fu-abc,
        because then when they're listed in the procedural database, they'll
        all show up under script-fu when you're listing the functions. This
        also helps distinguish them from plug-ins.
      </para>
    </sect3>
    <sect3>
      <title>
        <phrase>Registering The Function</phrase>
      </title>
      <para>
        Now, let's register the function with GIMP. This is done by
        calling the function <code>script-fu-register</code>. When
        GIMP reads in a
        script, it will execute this function, which registers the
        script with the procedural database. You can place this
        function call wherever you wish in your script, but I usually
        place it at the end, after all my other code.
      </para>
      <para>
        Here's the listing for registering this function (I will
        explain all its parameters in a minute):
      </para>
      <programlisting><![CDATA[
        (script-fu-register
          "script-fu-text-box"                        ;func name
          "Text Box"                                  ;menu label
          "Creates a simple text box, sized to fit\
            around the user's choice of text,\
            font, font size, and color."              ;description
          "Michael Terry"                             ;author
          "copyright 1997, Michael Terry"             ;copyright notice
          "October 27, 1997"                          ;date created
          ""                     ;image type that the script works on
          SF-STRING      "Text:"         "Text Box"   ;a string variable
          SF-FONT        "Font:"         "Charter"    ;a font variable
          SF-ADJUSTMENT  "Font size"     '(50 1 1000 1 10 0 1)
                                                      ;a spin-button
          SF-COLOR       "Color:"        '(0 0 0)     ;color variable
        )
        (script-fu-menu-register "script-fu-text-box" "<Toolbox>/Xtns/Script-Fu/Text")
      ]]></programlisting>
      <para>
        If you save these functions in a text file with a
        <filename>.scm</filename> suffix
        in your script directory, then choose
        <menuchoice><guimenu>Xtns</guimenu><guisubmenu>Script-Fu</guisubmenu><guimenuitem>Refresh Scripts</guimenuitem></menuchoice>,
        this new script will appear as
        <menuchoice><guimenu> Xtns</guimenu><guisubmenu>Script-Fu</guisubmenu><guisubmenu>Text</guisubmenu><guimenuitem>Text Box</guimenuitem></menuchoice>.
      </para>
      <para>
        If you invoke this new script, it won't do anything, of course, but
        you can view the prompts you created when registering the script (more
        information about what we did is covered next).
      </para>
      <para>
        Finally, if you invoke the Procedure Browser (
        <menuchoice><guimenu> Xtns</guimenu><guimenuitem>Procedure Browser</guimenuitem></menuchoice>),
        you'll notice that our script now
        appears in the database.
      </para>
    </sect3>
    <sect3>
      <title>
        <phrase>Steps For Registering The Script</phrase>
      </title>
      <para>
        To register our script with GIMP, we call the function
        script-fu-register, fill in the seven required parameters and add our
        script's own parameters, along with a description and default value
        for each parameter.
      </para>
      <itemizedlist>
        <title>
          <phrase>The Required Parameters</phrase>
        </title>
        <listitem>
          <para>
           The <emphasis>name</emphasis> of the function we
           defined. This is the function called when our script is invoked
           (the entry-point into our script). This is necessary because we may
           define additional functions within the same file, and GIMP needs to
           know which of these functions to call. In our example, we only
           defined one function, text-box, which we registered.
          </para>
        </listitem>
        <listitem>
          <para>
            The <emphasis>location</emphasis> in the menu where
            the script will be inserted. The exact location of the script is
            specified like a path in Unix, with the root of the path being
            either toolbox or right-click.
          </para>
          <para>
            If your script does not operate on an existing image (and thus
            creates a new image, like our Text Box script will), you'll want
            to insert it in the toolbox menu -- this is the menu in GIMP's
            main window (where all the tools are located: the selection tools,
            magnifying glass, etc.).
          </para>
          <para><!--FIXME: en needs a review-->
            If your script is intended to work on an image being edited,
            you'll want to insert it in the menu that appears when you
            right-click on an open image. The rest of the path points to
            the menu lists, menus and sub-menus. Thus, we registered our
            Text Box script in the Text menu of the Script-Fu menu of
            the Xtns menu of the toolbox (
            <menuchoice><guimenu> Xtns</guimenu><guisubmenu>Script-Fu</guisubmenu><guisubmenu>Text</guisubmenu><guimenuitem>Text Box</guimenuitem></menuchoice> ).
          </para>
          <para>
            If you notice, the Text sub-menu in the Script-Fu menu wasn't
            there when we began -- GIMP automatically creates any menus not
            already existing.
          </para>
        </listitem>
        <listitem>
          <para>
            A <emphasis>description</emphasis> of your
            script, to be displayed in the Procedure Browser.
          </para>
        </listitem>
        <listitem>
          <para><emphasis>Your name</emphasis> (the author of
            the script).
          </para>
        </listitem>
        <listitem>
          <para><emphasis>Copyright</emphasis> information.
          </para>
        </listitem>
        <listitem>
          <para>
            The <emphasis>date</emphasis> the script was
            made, or the last revision of the script.
          </para>
        </listitem>
        <listitem>
          <para>
            The <emphasis>types</emphasis> of images the script
            works on. This may be any of the following: RGB, RGBA, GRAY,
            GRAYA, INDEXED, INDEXEDA. Or it may be none at all -- in our case,
            we're creating an image, and thus don't need to define the type of
            image on which we work.
          </para>
        </listitem>
      </itemizedlist>
      <figure>
        <title>
          <phrase>The menu of our script.</phrase>
        </title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/using/script-fu-menu.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </figure>
    </sect3>
    <sect3>
      <title>
        <phrase>Registering The Script's Parameters</phrase>
      </title>
      <para>
        Once we have listed the required parameters, we then need to list the
        parameters that correspond to the parameters our script needs. When we
        list these params, we give hints as to what their types are. This is
        for the dialog which pops up when the user selects our script. We also
        provide a default value.
      </para>
      <para>
        This section of the registration process has the following format:
      </para>
      <informaltable>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>
                <para>Param Type</para>
              </entry>
              <entry>
                <para>Description</para>
              </entry>
              <entry>
                <para>Example</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>SF-IMAGE</para>
              </entry>
              <entry>
                <para>
                  If your script operates on an open image, this should be the
                  first parameter after the required parameters. GIMP will
                  pass in a reference to the image in this parameter.
                </para>
              </entry>
              <entry>
                <para>3</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>SF-DRAWABLE</para>
              </entry>
              <entry>
                <para>
                  If your script operates on an open image, this should be the
                  second parameter after the SF-IMAGE param. It refers to the
                  active layer. GIMP will pass in a reference to the active
                  layer in this parameter.
                </para>
              </entry>
              <entry>
                <para>17</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>SF-VALUE</para>
              </entry>
              <entry>
                <para>
                  Accepts numbers and strings. Note that quotes must be
                  escaped for default text, so better use SF-STRING.
                </para>
              </entry>
              <entry>
                <para>42</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>SF-STRING</para>
              </entry>
              <entry>
                <para>Accepts strings.</para>
              </entry>
              <entry>
                <para>"Some text"</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>SF-COLOR</para>
              </entry>
              <entry>
                <para>
                  Indicates that a color is requested in this parameter.
                </para>
              </entry>
              <entry>
                <para>'(0 102 255)</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>SF-TOGGLE</para>
              </entry>
              <entry>
                <para>
                  A checkbox is displayed, to get a Boolean value.
                </para>
              </entry>
              <entry>
                <para>TRUE or FALSE</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect3>
    <xi:include href="script-fu-gui-api.xml"/>
  </sect2>
  <sect2 id="gimp-using-script-fu-tutorial-script">
    <title>
      <phrase>Giving Our Script Some Guts</phrase>
    </title>
    <para>
      Let us continue with our training and add some functionality to our
      script.
    </para>
    <sect3>
      <title>
        <phrase>Creating A New Image</phrase>
      </title>
      <para>
        In the previous lesson, we created an empty function and registered it
        with GIMP. In this lesson, we want to provide functionality to our
        script -- we want to create a new image, add the user's text to it and
        resize the image to fit the text exactly.
      </para>
      <para>
        Once you know how to set variables, define functions and access list
        members, the rest is all downhill -- all you need to do is familiarize
        yourself with the functions available in GIMP's procedural database
        and call those functions directly. So fire up the DB Browser and let's
        get cookin'!
      </para>
      <para>
        Let's begin by making a new image. We'll create a new variable,
        <varname>theImage</varname>, set to the result of calling GIMP's
        built-in function <code>gimp-image-new</code>.
      </para>
      <para>
        As you can see from the DB Browser, the function
        <code>gimp-image-new</code> takes three parameters -- the
        image's width, height and the type of image. Because we'll
        later resize the image to fit the text, we'll make a 10x10 RGB
        image. We'll store the image's width and sizes in some
        variables, too, as we'll refer to and manipulate them later in
        the script.
      </para>
      <programlisting>
        (define (script-fu-text-box inText inFont inFontSize inTextColor)
        (let*
              (
                 ; define our local variables
                 ; create a new image:
                 (theImageWidth  10)
                 (theImageHeight 10)
                 (theImage (car
                                (gimp-image-new
                                 theImageWidth
                                 theImageHeight
                                 RGB
                                )
                           )
                 )
                 (theText)     ;a declaration for the text
                               ;we create later
      </programlisting>
      <para>
        Note: We used the value RGB to specify that the image is an RGB image.
        We could have also used 0, but RGB is more descriptive when we glance
        at the code.
      </para>
      <para>
        You should also notice that we took the head of the result of the
        function call. This may seem strange, because the database explicitly
        tells us that it returns only one value -- the ID of the newly created
        image. However, all GIMP functions return a list, even if there is
        only one element in the list, so we need to get the head of the list.
      </para>
    </sect3>
    <sect3>
      <title>
        <phrase>Adding A New Layer To The Image</phrase>
      </title>
      <para>
        Now that we have an image, we need to add a layer to it. We'll
        call the <code>gimp-layer-new</code> function to create the
        layer, passing
        in the ID of the image we just created. (From now on, instead
        of listing the complete function, we'll only list the lines
        we're adding to it. You can see the complete script 
        <link linkend="gimp-using-script-fu-tutorial-result">here</link>.)
        Because we've declared all of the local variables we'll use,
        we'll also close the parentheses marking the end of our
        variable declarations:
      </para>
      <programlisting>
        ;create a new layer for the image:
           (theLayer
                     (car
                          (gimp-layer-new
                           theImage
                           theImageWidth
                           theImageHeight
                           RGB-IMAGE
                           "layer 1"
                           100
                           NORMAL
                          )
                      )
            )
         ) ;end of our local variables
      </programlisting>
      <para>
        Once we have the new layer, we need to add it to the image:
      </para>
      <programlisting>
        (gimp-image-add-layer theImage theLayer 0)
      </programlisting>
      <para>
        Now, just for fun, let's see the fruits of our labors up until this
        point, and add this line to show the new, empty image:
      </para>
      <programlisting>
        (gimp-display-new theImage)
      </programlisting>
      <para>
        Save your work, select
        <menuchoice><guimenu>Xtns</guimenu><guisubmenu>Script-Fu</guisubmenu><guimenuitem>Refresh Scripts</guimenuitem></menuchoice>,
        run the script and a new image should pop up. It will probably
        contain garbage (random colors), because we haven't erased
        it. We'll get to that in a second.
      </para>
    </sect3>
    <sect3>
      <title>
        <phrase>Adding The Text</phrase>
      </title>
      <para>
        Go ahead and remove the line to display the image (or comment
        it out with a ; as the first character of the line).
      </para>
      <para>
        Before we add text to the image, we need to set the background
        and foreground colors so that the text appears in the color
        the user specified. We'll use the
        gimp-context-set-back/foreground functions:
      </para>
      <programlisting>
        (gimp-context-set-background '(255 255 255) )
        (gimp-context-set-foreground inTextColor)
      </programlisting>
      <para>
        With the colors properly set, let's now clean out the garbage
        currently in the image by filling the drawable with the background
        color:
      </para>
      <programlisting>
        (gimp-drawable-fill theLayer BACKGROUND-FILL)
      </programlisting>
      <para>
        With the image cleared, we're ready to add some text:
      </para>
      <programlisting>
        (set! theText
                      (car
                           (gimp-text-fontname
                            theImage theLayer
                            0 0
                            inText
                            0
                            TRUE
                            inFontSize PIXELS
                            "Sans")
                       )
        )
      </programlisting>
      <para>
        Although a long function call, it's fairly straightforward if
        you go over the parameters while looking at the function's
        entry in the DB Browser. Basically, we're creating a new text
        layer and assigning it to the variable
        <varname>theText</varname>.
      </para>
      <para>
        Now that we have the text, we can grab its width and height and resize
        the image and the image's layer to the text's size:
      </para>
      <programlisting>
        (set! theImageWidth   (car (gimp-drawable-width  theText) ) )
        (set! theImageHeight  (car (gimp-drawable-height theText) ) )

        (gimp-image-resize theImage theImageWidth theImageHeight 0 0)

        (gimp-layer-resize theLayer theImageWidth theImageHeight 0 0)
      </programlisting>
      <para>
        If you're like me, you're probably wondering what a drawable is when
        compared to a layer. The difference between the two is that a drawable
        is anything that can be drawn into, including layers but also
        channels, layer masks, the selection, etc; a layer is a more specific
        version of a drawable. In most cases, the distinction is not
        important.
      </para>
      <para>
        With the image ready to go, we can now re-add our display line:
      </para>
      <programlisting>
        (gimp-display-new theImage)
      </programlisting>
      <para>
        Save your work, refresh the database and give your first script a run!
      </para>
    </sect3>
    <sect3>
      <title>
        <phrase>Clearing The Dirty Flag</phrase>
      </title>
      <para>
        If you try to close the image created without first saving the file,
        GIMP will ask you if you want to save your work before you close the
        image. It asks this because the image is marked as dirty, or unsaved.
        In the case of our script, this is a nuisance for the times when we
        simply give it a test run and don't add or change anything in the
        resulting image -- that is, our work is easily reproducible in such a
        simple script, so it makes sense to get rid of this dirty flag.
      </para>
      <para>
        To do this, we can clear the dirty flag after displaying the image:
      </para>
      <programlisting>
        (gimp-image-clean-all theImage)
      </programlisting>
      <para>
        This will set dirty count to 0, making it appear to be a "clean"
        image.
      </para>
      <para>
        Whether to add this line or not is a matter of personal taste. I use
        it in scripts that produce new images, where the results are trivial,
        as in this case. If your script is very complicated, or if it works on
        an existing image, you will probably not want to use this function.
      </para>
    </sect3>
  </sect2>
  <sect2 id="gimp-using-script-fu-tutorial-extending-text-box">
    <title>
      <phrase>Extending The Text Box Script</phrase>
    </title>
    <sect3>
      <title>
        <phrase>Handling Undo Correctly</phrase>
      </title>
      <para>
        When creating a script, you want to give your users the ability to
        undo their actions, should they make a mistake. This is easily
        accomplished by calling the functions
        <code>gimp-undo-push-group-start</code>
        and <code>gimp-undo-push-group-end</code>
        around the code that manipulates the image. You can think of them as
        matched statements that let GIMP know when to start and stop recording
        manipulations on the image, so that those manipulations can later be
        undone.
      </para>
      <para>
        If you are creating a new image entirely, it doesn't make sense to use
        these functions because you're not changing an existing image.
        However, when you are changing an existing image, you most surely want
        to use these functions.
      </para>
      <para>
        Undoing a script works nearly flawlessly when using these functions.
      </para>
    </sect3>
    <sect3>
      <title>
        <phrase>Extending The Script A Little More</phrase>
      </title>
      <para>
        Now that we have a very handy-dandy script to create text
        boxes, let's add two features to it:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Currently, the image is resized to fit exactly around the
            text -- there's no room for anything, like drop shadows or
            special effects (even though many scripts will automatically
            resize the image as necessary). Let's add a buffer around
            the text, and even let the user specify how much buffer to
            add as a percentage of the size of the resultant text.
          </para>
        </listitem>
        <listitem>
          <para>
            This script could easily be used in other scripts that work
            with text. Let's extend it so that it returns the image and
            the layers, so other scripts can call this script and use
            the image and layers we create.
          </para>
        </listitem>
      </itemizedlist>
    </sect3>
    <sect3>
      <title>
        <phrase>
          Modifying The Parameters And The Registration Function
        </phrase>
      </title>
      <para>
        To let the user specify the amount of buffer, we'll add a parameter to
        our function and the registration function:
      </para>
      <programlisting>
        (define (script-fu-text-box inTest inFont inFontSize inTextColor inBufferAmount)
        (let*
              (
                 ; define our local variables
                 ; create a new image:
                 (theImageWidth  10)
                 (theImageHeight 10)
                 (theImage (car
                                (gimp-image-new
                                 theImageWidth
                                 theImageHeight
                                 RGB
                                )
                           )
                 )
                 (theText)          ;a declaration for the text
                                    ;we create later

                 (theBuffer)        ;<emphasis>added</emphasis>

                 (theLayer
                           (car
                               (gimp-layer-new
                                theImage
                                theImageWidth
                                theImageHeight
                                RGB-IMAGE
                                "layer 1"
                                100
                                NORMAL
                               )
                           )
                 )
              ) ;end of our local variables

         <replaceable>[Code here]</replaceable>
       )
      </programlisting>
      <programlisting><![CDATA[
        (script-fu-register
          "script-fu-text-box"                        ;func name
          "Text Box"                                  ;menu label
          "Creates a simple text box, sized to fit\
            around the user's choice of text,\
            font, font size, and color."              ;description
          "Michael Terry"                             ;author
          "copyright 1997, Michael Terry"             ;copyright notice
          "October 27, 1997"                          ;date created
          ""                     ;image type that the script works on
          SF-STRING      "Text:"         "Text Box"   ;a string variable
          SF-FONT        "Font:"         "Charter"    ;a font variable
          SF-ADJUSTMENT  "Font size"     '(50 1 1000 1 10 0 1)
                                                      ;a spin-button
          SF-COLOR       "Color:"        '(0 0 0)     ;color variable
          SF-ADJUSTMENT  "Buffer amount" '(35 0 100 1 10 1 0)
                                                      ;a slider
        )
        (script-fu-menu-register "script-fu-text-box" "<Toolbox>/Xtns/Script-Fu/Text")
      ]]></programlisting>
    </sect3>
    <sect3>
      <title>
        <phrase>Adding The New Code</phrase>
      </title>
      <para>
        We're going to add code in two places: right before we resize
        the image, and at the end of the script (to return the new
        image, the layer and the text).
      </para>
      <para>
        After we get the text's height and width, we need to resize
        these values based on the buffer amount specified by the
        user. We won't do any error checking to make sure it's in the
        range of 0-100% because it's not life-threatening, and because
        there's no reason why the user can't enter a value like "200"
        as the percent of buffer to add.
      </para>
      <programlisting>
        (set! theBuffer (* theImageHeight (/ inBufferAmount 100) ) )

        (set! theImageHeight (+ theImageHeight theBuffer theBuffer) )
        (set! theImageWidth  (+ theImageWidth  theBuffer theBuffer) )
      </programlisting>
      <para>
        All we're doing here is setting the buffer based on the height of the
        text, and adding it twice to both the height and width of our new
        image. (We add it twice to both dimensions because the buffer needs to
        be added to both sides of the text.)
      </para>
      <para>
        Now that we have resized the image to allow for a buffer, we
        need to center the text within the image. This is done by
        moving it to the (x, y) coordinates of (<varname>theBuffer</varname>,
        <varname>theBuffer</varname>). I added this line after
        resizing the layer and the image:
      </para>
      <programlisting>
        (gimp-layer-set-offsets theText theBuffer theBuffer)
      </programlisting>
      <para>
        Go ahead and save your script, and try it out after refreshing the
        database.
      </para>
      <para>
        All that is left to do is return our image, the layer, and the text
        layer. After displaying the image, we add this line:
      </para>
      <programlisting>
        (list theImage theLayer theText)
      </programlisting>
      <para>
        This is the last line of the function, making this list available to
        other scripts that want to use it.
      </para>
      <para>
        To use our new text box script in another script, we could write
        something like the following:
      </para>
      <programlisting>
        (set! theResult (script-fu-text-box
                         "Some text"
                         "Charter" "30"
                         '(0 0 0)
                         "35"
                        )
        )
        (gimp-image-flatten (car theResult))
      </programlisting>
      <para>
        Congratulations, you are on your way to your Black Belt of Script-Fu!
      </para>
    </sect3>
  </sect2>
  <sect2 id="gimp-using-script-fu-tutorial-result">
    <title>
      <phrase>Your script and its working</phrase>
    </title>
    <sect3>
      <title>
        <phrase>What you write</phrase>
      </title>
      <para>Below the complete script:</para>
      <programlisting><![CDATA[
        (script-fu-register
                  "script-fu-text-box"                        ;func name
                  "Text Box"                                  ;menu label
                  "Creates a simple text box, sized to fit\
                    around the user's choice of text,\
                    font, font size, and color."              ;description
                  "Michael Terry"                             ;author
                  "copyright 1997, Michael Terry"             ;copyright notice
                  "October 27, 1997"                          ;date created
                  ""                     ;image type that the script works on
                  SF-STRING      "Text:"         "Text Box"   ;a string variable
                  SF-FONT        "Font:"         "Charter"    ;a font variable
                  SF-ADJUSTMENT  "Font size"     '(50 1 1000 1 10 0 1)
                                                              ;a spin-button
                  SF-COLOR       "Color:"        '(0 0 0)     ;color variable
                  SF-ADJUSTMENT  "Buffer amount" '(35 0 100 1 10 1 0)
                                                              ;a slider
        )
        (script-fu-menu-register "script-fu-text-box" "<Toolbox>/Xtns/Script-Fu/Text")
        (define (script-fu-text-box inText inFont inFontSize inTextColor inBufferAmount)
          (let*
            (
              ; define our local variables
              ; create a new image:
              (theImageWidth  10)
              (theImageHeight 10)
              (theImage)
              (theImage
                        (car
                            (gimp-image-new
                              theImageWidth
                              theImageHeight
                              RGB
                            )
                        )
              )
              (theText)             ;a declaration for the text
              (theBuffer)           ;create a new layer for the image
              (theLayer
                        (car
                            (gimp-layer-new
                              theImage
                              theImageWidth
                              theImageHeight
                              RGB-IMAGE
                              "layer 1"
                              100
                              NORMAL
                            )
                        )
              )
            ) ;end of our local variables
            (gimp-image-add-layer theImage theLayer 0)
            (gimp-context-set-background '(255 255 255) )
            (gimp-context-set-foreground inTextColor)
            (gimp-drawable-fill theLayer BACKGROUND-FILL)
            (set! theText
                          (car
                                (gimp-text-fontname
                                theImage theLayer
                                0 0
                                inText
                                0
                                TRUE
                                inFontSize PIXELS
                                "Sans")
                            )
              )
            (set! theImageWidth   (car (gimp-drawable-width  theText) ) )
            (set! theImageHeight  (car (gimp-drawable-height theText) ) )
            (set! theBuffer (* theImageHeight (/ inBufferAmount 100) ) )
            (set! theImageHeight (+ theImageHeight theBuffer theBuffer) )
            (set! theImageWidth  (+ theImageWidth  theBuffer theBuffer) )
            (gimp-image-resize theImage theImageWidth theImageHeight 0 0)
            (gimp-layer-resize theLayer theImageWidth theImageHeight 0 0)
            (gimp-layer-set-offsets theText theBuffer theBuffer)
            (gimp-display-new theImage)
            (list theImage theLayer theText)
          )
        )
      ]]></programlisting>
    </sect3>
    <sect3>
      <title>What you obtain</title>
      <figure>
        <title>
          <phrase>And the result on the screen.</phrase>
        </title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/using/script-fu-screen.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </figure>
    </sect3>
  </sect2>
</sect1>
