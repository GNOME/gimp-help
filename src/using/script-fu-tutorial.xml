<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                       "http://www.docbook.org/xml/4.3/docbookx.dtd">
<!-- section history:
  2007-06-14 alex falappa: finished italian translation
  2007-04-13 alex falappa: started it translation
  2008-03-12 jpl : french update
-->
<sect1 id="gimp-using-script-fu-tutorial"
 xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>A Script-Fu Tutorial</title>
  <indexterm>
    <primary>Script-Fu</primary>
    <secondary>Tutorial</secondary>
  </indexterm>
  <para>
    In this training course, we'll introduce you to the fundamentals of Scheme
    necessary to use Script-Fu, and then build a handy script that you can add
    to your toolbox of scripts. The script prompts the user for some text,
    then creates a new image sized perfectly to the text. We will then enhance
    the script to allow for a buffer of space around the text. We will
    conclude with a few suggestions for ways to ramp up your knowledge of
    Script-Fu.
  </para>
  <note>
    <para>
      This section was adapted from a tutorial written for the
      <application><acronym>GIMP</acronym> 1</application> User
      Manual by Mike Terry.
    </para>
  </note>

  <sect2 id="gimp-using-script-fu-tutorial-scheme">
    <title>Getting Acquainted With Scheme</title>
    <sect3>
      <title>Start with Scheme</title>
      <para>
        <ulink url="https://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</ulink>
        is a dialect of the Lisp family of programming languages. GIMP uses
        TinyScheme, which is a lightweight interpreter of a subset of the
        so-called R5RS standard.
      </para>
      <para>The first thing to learn is that:</para>
      <blockquote>
        <para>
          Every statement in Scheme is surrounded by parentheses ().
        </para>
      </blockquote>
      <para>The second thing you need to know is that:</para>
      <blockquote>
        <para>
          The function name/operator is always the first item in the
          parentheses, and the rest of the items are parameters to the
          function.
        </para>
      </blockquote>
      <para>
        However, not everything enclosed in parentheses is a function &mdash;
        they can also be items in a list &mdash; but we'll get to that later.
        This notation is referred to as prefix notation, because the function
        prefixes everything else. If you're familiar with postfix notation, or
        own a calculator that uses Reverse Polish Notation (such as most HP
        calculators), you should have no problem adapting to formulating
        expressions in Scheme.
      </para>
      <para>The third thing to understand is that:</para>
      <blockquote>
        <para>
          Mathematical operators are also considered functions, and thus are
          listed first when writing mathematical expressions.
        </para>
      </blockquote>
      <para>
        This follows logically from the prefix notation that we just
        mentioned.
      </para>
    </sect3>

    <sect3>
      <title>Examples Of Prefix, Infix, And Postfix Notations</title>
      <para>
        Here are some quick examples illustrating the differences between
        <emphasis>prefix</emphasis>, <emphasis>infix</emphasis>, and
        <emphasis>postfix</emphasis> notations. We'll add a 1 and 23 together:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Prefix notation: <userinput>+ 1 23</userinput>
            (the way Scheme will want it)
          </para>
        </listitem>
        <listitem>
          <para>
            Infix notation: <userinput>1 + 23</userinput>
            (the way we <quote>normally</quote> write it)
          </para>
        </listitem>
        <listitem>
          <para>
            Postfix notation: <userinput>1 23 +</userinput>
            (the way many <acronym>HP</acronym> calculators will want it)
          </para>
        </listitem>
      </itemizedlist>
    </sect3>

    <sect3>
      <title>Practicing In Scheme</title>
      <para>
        In GIMP, select
        <menuchoice>
          <guimenu>Filters</guimenu>
          <guisubmenu>Development</guisubmenu>
          <guisubmenu>Script-Fu</guisubmenu>
          <guimenuitem>Script-Fu Console</guimenuitem>
        </menuchoice> from the main menu.
        This will start up the Script-Fu Console window, which allows us to
        work interactively in Scheme.
      </para>
    </sect3>

    <sect3 id="gimp-using-script-fu-tutorial-console">
      <title>The Script-Fu Console Window</title>
      <para>
        At the bottom of this window is a text entry field for commands.
        Here, we can test out simple Scheme commands interactively. Let's
        start out easy, and add some numbers:
      </para>
      <programlisting>(+ 3 5)</programlisting>
      <para>
        Typing this in and hitting <keycap>Enter</keycap>
        yields the expected answer of 8 in the center window.
      </para>
      <figure>
        <title>Use Script-Fu Console.</title>
        <mediaobject>
          <imageobject>
            <imagedata format="PNG"
              fileref="images/using/script-fu-console.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
        The <quote>+</quote> function can take more arguments, so we can add
        more than one number:
      </para>
      <programlisting>(+ 3 5 6)</programlisting>
      <para>This also yields the expected answer of 14.</para>
      <para>
        So far, so good &mdash; we type in a Scheme statement and it's executed
        immediately in the Script-Fu Console window. Now for a word of
        caution&hellip;
      </para>
    </sect3>

    <sect3>
      <title>Watch Out For Extra Parentheses</title>
      <para>
        If you're like me, you're used to being able to use extra parentheses
        whenever you want to &mdash; like when you're typing a complex
        mathematical
        equation and you want to separate the parts by parentheses to make it
        clearer when you read it. In Scheme, you have to be careful and not
        insert these extra parentheses incorrectly. For example, say we wanted
        to add 3 to the result of adding 5 and 6 together:
      </para>
      <programlisting>3 + (5 + 6) + 7 = ?</programlisting>
      <para>
        Knowing that the + operator can take a list of numbers to add, you
        might be tempted to convert the above to the following:
      </para>
      <programlisting>(+ 3 (5 6) 7)</programlisting>
      <para>
        However, this is incorrect &mdash; remember, every statement in Scheme
        starts and ends with parens, so the Scheme interpreter will think that
        you're trying to call a function named <quote>5</quote> in the second
        group of parens, rather than summing those numbers before adding them
        to 3.
      </para>
      <para>The correct way to write the above statement would be:</para>
      <programlisting>(+ 3 (+ 5 6) 7)</programlisting>
    </sect3>

    <sect3>
      <title>Make Sure You Have The Proper Spacing, Too</title>
      <para>
        If you are familiar with other programming languages, like C/C++, Perl
        or Java, you know that you don't need white space around mathematical
        operators to properly form an expression:
      </para>
      <programlisting>
        <literal>3+5, 3 +5, 3+ 5</literal>
      </programlisting>
      <para>
        These are all accepted by C/C++, Perl and Java compilers. However, the
        same is not true for Scheme. You must have a space after a
        mathematical operator (or any other function name or operator) in
        Scheme for it to be correctly interpreted by the Scheme interpreter.
      </para>
      <para>
        Practice a bit with simple mathematical equations in the Script-Fu
        Console until you're totally comfortable with these initial concepts.
      </para>
    </sect3>
  </sect2>

  <sect2 id="gimp-using-script-fu-tutorial-identifier">
    <title>Variables And Functions</title>
    <para>
      Now that we know that every Scheme statement is enclosed in parentheses,
      and that the function name/operator is listed first, we need to know how
      to create and use variables, and how to create and use functions. We'll
      start with the variables.
    </para>

    <sect3>
      <title>Declaring Variables</title>
      <para>
        Although there are a couple of different methods for declaring
        variables, the preferred method is to use the <command>let*</command>
        construct. If
        you're familiar with other programming languages, this construct is
        equivalent to defining a list of local variables and a scope in which
        they're active. As an example, to declare two variables, a and b,
        initialized to 1 and 2, respectively, you'd write:
      </para>
      <programlisting>
        (let*
           (
              (a 1)
              (b 2)
           )
           (+ a b)
        )
      </programlisting>
      <para>or, as one line:</para>
      <programlisting>(let* ( (a 1) (b 2) ) (+ a b) )</programlisting>
      <note>
        <para>
          You'll have to put all of this on one line if you're using the
          console window. In general, however, you'll want to adopt a similar
          practice of indentation to help make your scripts more readable.
          We'll talk a bit more about this in the section on White Space.
        </para>
      </note>
      <para>
        This declares two local variables, a and b, initializes them, then
        prints the sum of the two variables.
      </para>
    </sect3>

    <sect3>
      <title>What Is A Local Variable?</title>
      <para>
        You'll notice that we wrote the summation <code>(+ a b)</code> within
        the parens of the <code>let*</code> expression, not after it.
      </para>
      <para>
        This is because the <code>let*</code>
        statement defines an area in your script in which the declared
        variables are usable; if you type the <userinput>(+ a b)</userinput>
        statement after the <userinput>(let* &hellip;)</userinput> statement,
        you'll get an error, because the declared
        variables are only valid within the context of the <code>let*</code>
        statement; they are what programmers call local variables.
      </para>
    </sect3>

    <sect3>
      <title>The General Syntax Of <code>let*</code></title>
      <para>The general form of a <code>let*</code> statement is:</para>
      <programlisting>
        (let* ( <replaceable>variables</replaceable> )
          <replaceable>expressions</replaceable> )
      </programlisting>
      <para>
        where variables are declared within parens, e.g.,
        <userinput>(a 2)</userinput>, and
        expressions are any valid Scheme expressions. Remember that the
        variables declared here are only valid within the
        <code>let*</code> statement &mdash; they're local variables.
      </para>
    </sect3>

    <sect3>
      <title>White Space</title>
      <para>
        Previously, we mentioned the fact that you'll probably want to use
        indentation to help clarify and organize your scripts. This is a good
        policy to adopt, and is not a problem in Scheme &mdash; white space is
        ignored by the Scheme interpreter, and can thus be liberally applied
        to help clarify and organize the code within a script. However, if
        you're working in Script-Fu's Console window, you'll have to enter an
        entire expression on one line; that is, everything between the opening
        and closing parens of an expression must come on one line in the
        Script-Fu Console window.
      </para>
    </sect3>

    <sect3>
      <title>Assigning A New Value To A Variable</title>
      <para>
        Once you've initialized a variable, you might need to change its value
        later on in the script. Use the <code>set!</code> statement to change
        the variable's value:
      </para>
      <programlisting>
        (let* ( (theNum 10) ) (set! theNum (+ theNum theNum)) )
      </programlisting>
      <para>
        Try to guess what the above statement will do, then go ahead and enter
        it in the Script-Fu Console window.
      </para>
    </sect3>

    <sect3>
      <title>Functions</title>
      <para>
        Now that you've got the hang of variables, let's get to work with some
        functions. You declare a function with the following syntax:
      </para>
      <programlisting>
        (define
           (
              <replaceable>name</replaceable>
              <replaceable>param-list</replaceable>
           )
           <replaceable>expressions</replaceable>
        )
      </programlisting>
      <para>
        where <replaceable>name</replaceable> is the name assigned to this
        function, <replaceable>param-list</replaceable> is a space-delimited
        list of parameter names, and <replaceable>expressions</replaceable>
        is a series of expressions that the function executes when it's
        called. For example:
      </para>
      <programlisting>(define (AddXY inX inY) (+ inX inY) )</programlisting>
      <para>
        <varname>AddXY</varname> is the function's name and
        <varname>inX</varname> and <varname>inY</varname>
        are the variables. This function takes its two parameters and adds
        them together.
      </para>
      <para>
        If you've programmed in other imperative languages (like C/C++, Java,
        Pascal, etc.), you might notice that a couple of things are absent in
        this function definition when compared to other programming languages.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            First, notice that the parameters don't have any
            <quote>types</quote> (that is,
            we didn't declare them as strings, or integers, etc.). Scheme is a
            type-less language. This is handy and allows for quicker script
            writing.
          </para>
        </listitem>
        <listitem>
          <para>
            Second, notice that we don't need to worry about how to
            <quote>return</quote> the result of our function &mdash; the last
            statement is the value <quote>returned</quote> when calling this
            function. Type the function into the
            console, then try something like:
          </para>
          <programlisting>(AddXY (AddXY 5 6) 4)</programlisting>
        </listitem>
      </itemizedlist>
    </sect3>
  </sect2>

  <sect2 id="gimp-using-script-fu-tutorial-lists">
    <title>Lists, Lists And More Lists</title>
    <para>
      We've trained you in variables and functions, and now enter the
      murky swamps of Scheme's lists.
    </para>

    <sect3>
      <title>Defining A List</title>
      <para>
        Before we talk more about lists, it is necessary that you know
        the difference between atomic values and lists.
      </para>
      <para>
        You've already seen atomic values when we initialized
        variables in the previous lesson. An atomic value is a single
        value. So, for example, we can assign the variable
        <quote><varname>x</varname></quote> the
        single value of 8 in the following statement:
      </para>
      <programlisting>(let* ( (x 8) ) x)</programlisting>
      <para>
        (We added the expression <varname>x</varname> at the end to print out
        the value assigned to <varname>x</varname>&mdash;normally you won't
        need to do this. Notice how <code>let*</code> operates just like a
        function: The value of the last statement is the value returned.)
      </para>
      <para>
        A variable may also refer to a list of values, rather than a
        single value. To assign the variable <varname>x</varname> the
        list of values 1, 3, 5, we'd type:
      </para>
      <programlisting>(let* ( (x '(1 3 5))) x)</programlisting>
      <para>
        Try typing both statements into the Script-Fu Console and
        notice how it replies. When you type the first statement in,
        it simply replies with the result:
      </para>
      <programlisting>8</programlisting>
      <para>
        However, when you type in the other statement, it replies with
        the following result:
      </para>
      <programlisting>(1 3 5)</programlisting>
      <para>
        When it replies with the value 8 it is informing you that
        <varname>x</varname> contains the atomic value 8. However,
        when it replies with <computeroutput>(1 3 5)</computeroutput>, it is
        then informing you that
        <varname>x</varname> contains not a single value, but a list
        of values. Notice that there are no commas in our declaration
        or assignment of the list, nor in the printed result.
      </para>
      <para>The syntax to define a list is:</para>
      <programlisting>'(a b c)</programlisting>
      <para>
        where <varname>a</varname>, <varname>b</varname>, and
        <varname>c</varname> are literals. We use the apostrophe
        (<code>'</code>)
        to indicate that what follows in the parentheses is a list of
        literal values, rather than a function or expression.
      </para>
      <para>An empty list can be defined as such:</para>
      <programlisting>'()</programlisting>
      <para>or simply:</para>
      <programlisting>()</programlisting>
      <para>Lists can contain atomic values, as well as other lists:</para>
      <programlisting>
(let*
   (
        (x
           '("GIMP" (1 2 3) ("is" ("great" () ) ) )
        )
    )
    x
)
      </programlisting>
      <para>
        Notice that after the first apostrophe, you no longer need to use an
        apostrophe when defining the inner lists. Go ahead and copy the
        statement into the Script-Fu Console and see what it returns.
      </para>
      <para>
        You should notice that the result returned is not a list of
        single, atomic values; rather, it is a list of a literal
        <code>("GIMP")</code>, the list <code>(1 2 3)</code>, etc.
      </para>
    </sect3>

    <sect3>
      <title>How To Think Of Lists</title>
      <para>
        It's useful to think of lists as composed of a <quote>head</quote>
        and a <quote>tail</quote>.
        The head is the first element of the list, the tail the rest of the
        list. You'll see why this is important when we discuss how to add to
        lists and how to access elements in the list.
      </para>
    </sect3>

    <sect3>
      <title>Creating Lists Through Concatenation (The Cons Function)</title>
      <para>
        One of the more common functions you'll encounter is the cons
        function. It takes a value and places it to its second argument, a
        list. From the previous section, I suggested that you think of a list
        as being composed of an element (the head) and the remainder of the
        list (the tail). This is exactly how cons functions &mdash; it adds an
        element to the head of a list. Thus, you could create a list as
        follows:
      </para>
      <programlisting>(cons 1 '(2 3 4) )</programlisting>
      <para>The result is the list <code>(1 2 3 4)</code>.</para>
      <para>You could also create a list with one element:</para>
      <programlisting>(cons 1 () )</programlisting>
      <para>
        You can use previously declared variables in place of any literals, as
        you would expect.
      </para>
    </sect3>

    <sect3>
      <title>Defining A List Using The <code>list</code> Function</title>
      <para>
        To define a list composed of literals or previously declared
        variables, use the <function>list</function> function:
      </para>
      <programlisting>(list 5 4 3 a b c)</programlisting>
      <para>
        This will compose and return a list containing the values held
        by the variables <varname>a</varname>, <varname>b</varname>
        and <varname>c</varname>. For example:
      </para>
      <programlisting>
        (let*  (
                  (a 1)
                  (b 2)
                  (c 3)
               )

               (list 5 4 3 a b c)
        )
      </programlisting>
      <para>
        This code creates the list <code>(5 4 3 1 2 3)</code>.
      </para>
    </sect3>

    <sect3>
      <title>Accessing Values In A List</title>
      <para>
        To access the values in a list, use the functions
        <function>car</function> and <function>cdr</function>,
        which return the first element of the list and the rest of the list,
        respectively. These functions break the list down into the head::tail
        construct I mentioned earlier.
      </para>
    </sect3>

    <sect3>
      <title>The <function>car</function> Function</title>
      <para>
        <function>car</function> returns the first element of the list (the
        head of the list). The list needs to be non-null (not empty). Thus, the
        following returns the first element of the list:
      </para>
      <programlisting>(car '("first" 2 "third"))</programlisting>
      <para>which is:</para>
      <programlisting>"first"</programlisting>
    </sect3>

    <sect3>
      <title>The <function>cdr</function> function</title>
      <para>
        <function>cdr</function> returns the remainder of the list after the
        first element (the tail of the list). If there is only one element in
        the list, it returns an empty list.
      </para>
      <programlisting>(cdr '("first" 2 "third"))</programlisting>
      <para>returns:</para>
      <programlisting>(2 "third")</programlisting>
      <para>whereas the following:</para>
      <programlisting>(cdr '("one and only"))</programlisting>
      <para>returns:</para>
      <programlisting>()</programlisting>
    </sect3>

    <sect3>
      <title>Accessing Other Elements In A List</title>
      <para>
        OK, great, we can get the first element in a list, as well as
        the rest of the list, but how do we access the second, third
        or other elements of a list? There exist several "convenience"
        functions to access, for example, the head of the head of the
        tail of a list (<code>caadr</code>), the tail of the tail of a
        list (<code>cddr</code>), etc.
      </para>
      <para>
        The basic naming convention is easy: The a's and d's represent
        the heads and tails of lists, so
      </para>
      <programlisting>(car (cdr (car x) ) )</programlisting>
      <para>could be written as:</para>
      <programlisting>(cadar x)</programlisting>
      <para>
        To get some practice with list-accessing functions, try typing in the
        following (except all on one line if you're using the console); use
        different variations of <function>car</function> and
        <function>cdr</function> to access the different elements of the list:
      </para>
      <programlisting>
        (let* (
                 (x  '( (1 2 (3 4 5) 6)  7  8  (9 10) )
                 )
              )
              ; place your car/cdr code here
        )
      </programlisting>
      <para>
        Try accessing the number 3 in the list using only two function
        calls. If you can do that, you're on your way to becoming a
        Script-Fu Master!
      </para>
      <note>
        <para>
          In Scheme, a semicolon (<code>;</code>) marks the beginning of a
          comment. It, and everything that follows it on the same line, are
          ignored by the script interpreter, so you can use this to add
          comments to refresh your memory when you look at the script later.
        </para>
      </note>
    </sect3>
  </sect2>

  <sect2 id="gimp-using-script-fu-tutorial-first-script">
    <title>Your First Script-Fu Script</title>
    <para>
      Do you not need to stop and catch your breath? No? Well then,
      let's proceed with your fourth lesson &mdash; your first Script-Fu
      Script.
    </para>

    <sect3>
      <title>Creating A Text Box Script</title>
      <para>
        One of the most common operations I perform in <acronym>GIMP</acronym>
        is creating a box with some text in it for a web page, a logo or
        whatever. However, you never quite know how big to make the
        initial image when you start out. You don't know how much
        space the text will fill with the font and font size you
        want.
      </para>
      <para>
        This problem can be solved and automated with Script-Fu.
      </para>
      <para>
        We will, therefore, create a script, called Text Box, which
        creates an image correctly sized to fit snugly around a line
        of text the user inputs. We'll also let the user choose the
        font, font size and text color.
      </para>
    </sect3>

    <sect3>
      <title>Editing And Storing Your Scripts</title>
      <para>
        Up until now, we've been working in the Script-Fu Console. Now,
        however, we're going to switch to editing script files. Script files
        should be plain text files that you can edit in a text or code editor.
        The name you give is not that important, except for being able to
        recognize the script. You should give your script file the extension
        <quote>.scm</quote>.
      </para>
      <para>
        Where you place your scripts is a matter of preference. In GIMP's
        <link linkend="gimp-prefs-folders-scripts">folder preferences</link>
        you can see in which folders GIMP looks for scripts. It is also possible
        to add a new folder there.
        The folder where GIMP stores its own scripts is usually not the best
        choice for your scripts, but for the rest feel free to choose
        what suits you best.
      </para>
    </sect3>

    <sect3>
      <title>The Bare Essentials</title>
      <para>
        Every Script-Fu script defines at least one function, which is the
        script's main function. This is where you do the work.
      </para>
      <para>
        Every script must also register with the procedural database, so you
        can access it within <acronym>GIMP</acronym>.
      </para>
      <para>We'll define the main function first:</para>
      <programlisting>
        (define (script-fu-text-box inText inFont inFontSize inTextColor))
      </programlisting>
      <para>
        Here, we've defined a new function called
        <function>script-fu-text-box</function> that
        takes four parameters, which will later correspond to some text, a
        font, the font size, and the text's color. The function is currently
        empty and thus does nothing. So far, so good &mdash; nothing new,
        nothing fancy.
      </para>
    </sect3>

    <sect3>
      <title>Naming Conventions</title>
      <para>
        Scheme's naming conventions seem to prefer lowercase letters with
        hyphens, which I've followed in the naming of the function. However,
        I've departed from the convention with the parameters. I like more
        descriptive names for my parameters and variables, and thus add the
        "in" prefix to the parameters so I can quickly see that they're values
        passed into the script, rather than created within it. I use the
        prefix "the" for variables defined within the script.
      </para>
      <para>
        It's <acronym>GIMP</acronym> convention to name your script functions
        <function>script-fu-abc</function>,
        because then when they're listed in the procedural database, they'll
        all show up under Script-Fu when you're listing the functions. This
        also helps distinguish them from plug-ins.
      </para>
    </sect3>

    <sect3>
      <title>Registering The Function</title>
      <para>
        Now, let's register the function with <acronym>GIMP</acronym>. This is
        done by calling the function <function>script-fu-register</function>.
        When <acronym>GIMP</acronym> reads in a
        script, it will execute this function, which registers the
        script with the procedural database. You can place this
        function call wherever you wish in your script, but I usually
        place it at the end, after all my other code.
      </para>
      <para>
        Here's the listing for registering this function (I will
        explain all its parameters in a minute):
      </para>
      <programlisting><![CDATA[
  (script-fu-register
    "script-fu-text-box"                        ;function name
    "Text Box"                                  ;menu label
    "Creates a simple text box, sized to fit\
      around the user's choice of text,\
      font, font size, and color."              ;description
    "Michael Terry"                             ;author
    "copyright 1997, Michael Terry;\
      2009, the GIMP Documentation Team"        ;copyright notice
    "October 27, 1997"                          ;date created
    ""                                      ;image type that the script works on
    SF-STRING      "Text"          "Text Box"   ;a string variable
    SF-FONT        "Font"          "Charter"    ;a font variable
    SF-ADJUSTMENT  "Font size"     '(50 1 1000 1 10 0 1)
                                                ;a spin-button
    SF-COLOR       "Color"         '(0 0 0)     ;color variable
  )
  (script-fu-menu-register "script-fu-text-box" "<Image>/Filters/Tutorial")
      ]]></programlisting>
      <para>
        Save these functions in a text file with a
        <filename class="extension">.scm</filename> suffix in a subdirectory
        of your script directory, with the same name as your script file, then
        restart <acronym>GIMP</acronym>.
        The new script will appear as
        <menuchoice>
          <guimenu>Filters</guimenu>
          <guisubmenu>Tutorial</guisubmenu>
          <guimenuitem>Text Box</guimenuitem>
        </menuchoice>.
      </para>
      <para>
        If you invoke this new script, it won't do anything, of course, but
        you can view the prompts you created when registering the script (more
        information about what we did is covered next).
      </para>
      <para>
        Finally, if you invoke the Procedure Browser (
        <menuchoice>
          <guimenu>Help</guimenu>
          <guimenuitem>Procedure Browser</guimenuitem>
        </menuchoice>),
        you'll notice that our script now appears in the database.
      </para>
    </sect3>

    <sect3>
      <title>Steps For Registering The Script</title>
      <para>
        To register our script with <acronym>GIMP</acronym>, we call the
        function <function>script-fu-register</function>, fill in the seven
        required parameters and add our script's own parameters, along with a
        description and default value for each parameter.
      </para>
      <itemizedlist>
        <title>The Required Parameters</title>
        <listitem>
          <para>
           The <emphasis>name</emphasis> of the function we
           defined. This is the function called when our script is invoked
           (the entry-point into our script). This is necessary because we may
           define additional functions within the same file, and
           <acronym>GIMP</acronym> needs to
           know which of these functions to call. In our example, we only
           defined one function, text-box, which we registered.
          </para>
        </listitem>
        <listitem>
          <para>
            The <emphasis>menu label</emphasis> is the name that will be
            shown in the menu. To specify the location, see
            <xref linkend="script-fu-adding-menu-location"/>.
          </para>
        </listitem>
        <listitem>
          <para>
            A <emphasis>description</emphasis> of your
            script, to be displayed in the Procedure Browser.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis>Your name</emphasis> (the author of the script).
          </para>
        </listitem>
        <listitem>
          <para><emphasis>Copyright</emphasis> information.</para>
        </listitem>
        <listitem>
          <para>
            The <emphasis>date</emphasis> the script was
            made, or the last revision of the script.
          </para>
        </listitem>
        <listitem>
          <para>
            The <emphasis>types</emphasis> of images the script
            works on. This may be any of the following: RGB, RGBA, GRAY,
            GRAYA, INDEXED, INDEXEDA. Or it may be none
            at all &mdash; in our case,
            we're creating an image, and thus don't need to define the type of
            image on which we work.
          </para>
        </listitem>
      </itemizedlist>
    </sect3>

    <sect3>
      <title>Registering The Script's Parameters</title>
      <para>
        Once we have listed the required parameters, we then need to list the
        parameters that correspond to the parameters our script needs. When we
        list these params, we give hints as to what their types are. This is
        for the dialog which pops up when the user selects our script. We also
        provide a default value.
      </para>
      <para>
        This section of the registration process has the following format:
      </para>
      <informaltable>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>
                <para>Param Type</para>
              </entry>
              <entry>
                <para>Description</para>
              </entry>
              <entry>
                <para>Example</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para><constant>SF-IMAGE</constant></para>
              </entry>
              <entry>
                <para>
                  If your script operates on an open image, this should be the
                  first parameter after the required parameters.
                  <acronym>GIMP</acronym> will
                  pass in a reference to the image in this parameter.
                </para>
              </entry>
              <entry>
                <para>3</para>
              </entry>
            </row>
            <row>
              <entry>
                <para><constant>SF-DRAWABLE</constant></para>
              </entry>
              <entry>
                <para>
                  If your script operates on an open image, this should be the
                  second parameter after the <constant>SF-IMAGE</constant>
                  param. It
                  refers to the active layer. <acronym>GIMP</acronym> will pass
                  in a reference to the active layer in this parameter.
                </para>
              </entry>
              <entry>
                <para>17</para>
              </entry>
            </row>
            <row>
              <entry>
                <para><constant>SF-STRING</constant></para>
              </entry>
              <entry>
                <para>Accepts strings.</para>
              </entry>
              <entry>
                <para>"Some text"</para>
              </entry>
            </row>
            <row>
              <entry>
                <para><constant>SF-COLOR</constant></para>
              </entry>
              <entry>
                <para>
                  Indicates that a color is requested in this parameter.
                </para>
              </entry>
              <entry>
                <para>'(0 102 255)</para>
              </entry>
            </row>
            <row>
              <entry>
                <para><constant>SF-TOGGLE</constant></para>
              </entry>
              <entry>
                <para>
                  A checkbox is displayed, to get a Boolean value.
                </para>
              </entry>
              <entry>
                <para>TRUE or FALSE</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect3>
    <xi:include href="script-fu-gui-api.xml"/>

    <sect3 id="script-fu-adding-menu-location">
      <title>Registering the Menu Location</title>
      <para>
        Once we have registered our script, we need to tell GIMP where it
        should be found in the menu.
      </para>
      <para>
        The best menu location of your script depends on its function. Most
        scripts are found in the <guimenu>Filters</guimenu> and
        <guimenu>Colors</guimenu> menus.
      </para>
      <para>
        For the current script, which creates a new image, we choose a submenu
        of
        <menuchoice>
          <guimenu>Filters</guimenu>
          <guisubmenu>Tutorial</guisubmenu>
        </menuchoice>.
        This is what the line with the <code>script-fu-menu-register</code>
        function does.
        Thus, we registered our Text Box script here:
        <menuchoice>
          <guimenu>Filters</guimenu>
          <guisubmenu>Tutorial</guisubmenu>
          <guimenuitem>Text Box</guimenuitem>
        </menuchoice>.
      </para>
      <para>
        Any submenu that you specify in your script that doesn't exist yet
        will be automatically created by <acronym>GIMP</acronym>.
      </para>
    </sect3>
  </sect2>

  <sect2 id="gimp-using-script-fu-tutorial-script">
    <title>Adding Additional Functionality</title>
    <para>
      Let us continue with our training and add some functionality to our
      script.
    </para>

    <sect3>
      <title>Creating A New Image</title>
      <para>
        In the previous lesson, we created an empty function and registered it
        with <acronym>GIMP</acronym>. In this lesson, we want to provide
        functionality to our script &mdash; we want to create a new image,
        add the user's text to it and resize the image to fit the text exactly.
      </para>
      <para>
        Once you know how to set variables, define functions and access list
        members, the rest is all downhill &mdash; all you need to do is
        familiarize yourself with the functions available in
        <acronym>GIMP</acronym>'s procedural database and call those functions
        directly. Open the
        <xref linkend="plug-in-dbbrowser"/>.
      </para>
      <para>
        Let's begin by making a new image. We'll create a new variable,
        <varname>theImage</varname>, set to the result of calling
        <acronym>GIMP</acronym>'s
        built-in function <function>gimp-image-new</function>.
      </para>
      <para>
        As you can see from the DB Browser, the function
        <function>gimp-image-new</function> takes three parameters &mdash; the
        image's width, height and the type of image. Because we'll
        later resize the image to fit the text, we'll make a 10Ã—10 pixels
        <acronym>RGB</acronym>
        image. We'll store the image's width and sizes in some
        variables, too, as we'll refer to and manipulate them later in
        the script.
      </para>
      <programlisting>
        (define (script-fu-text-box inText inFont inFontSize inTextColor)
        (let*
              (
                 ; define our local variables
                 ; create a new image:
                 (theImageWidth  10)
                 (theImageHeight 10)
                 (theImage (car
                                (gimp-image-new
                                 theImageWidth
                                 theImageHeight
                                 RGB
                                )
                           )
                 )
                 (theText)     ;a declaration for the text
                               ;we create later
      </programlisting>
      <para>
        Note: We used the value <code>RGB</code> to specify that the image
        is an <acronym>RGB</acronym> image. We could have also used
        <code>0</code>, but <acronym>RGB</acronym> is more descriptive
        when we glance at the code.
      </para>
      <para>
        You should also notice that we took the head of the result of the
        function call. This may seem strange, because the database explicitly
        tells us that it returns only one value &mdash; the ID of the newly
        created image. However, all <acronym>GIMP</acronym> functions return a
        list, even if there is
        only one element in the list, so we need to get the head of the list.
      </para>
    </sect3>

    <sect3>
      <title>Adding A New Layer To The Image</title>
      <para>
        Now that we have an image, we need to add a layer to it. We'll
        call the <function>gimp-layer-new</function> function to create the
        layer, passing
        in the ID of the image we just created. (From now on, instead
        of listing the complete function, we'll only list the lines
        we're adding to it. You can see the complete script
        <link linkend="gimp-using-script-fu-tutorial-result">here</link>.)
        Because we've declared all of the local variables we'll use,
        we'll also close the parentheses marking the end of our
        variable declarations:
      </para>
      <programlisting>
        ;create a new layer for the image:
           (theLayer
                     (car
                          (gimp-layer-new
                           theImage
                           "layer 1"
                           theImageWidth
                           theImageHeight
                           RGB-IMAGE
                           100
                           LAYER-MODE-NORMAL
                          )
                      )
            )
         ) ;end of our local variables
      </programlisting>
      <para>Once we have the new layer, we need to add it to the image:</para>
      <programlisting>
        (gimp-image-insert-layer theImage theLayer 0 0)
      </programlisting>
      <para>
        Now, just for fun, let's see the fruits of our labors up until this
        point, and add this line to show the new, empty image:
      </para>
      <programlisting>(gimp-display-new theImage)</programlisting>
      <para>
        Save your work, restart <acronym>GIMP</acronym>,
        run the script and a new image should pop up. It will probably
        contain garbage (random colors), because we haven't erased
        it. We'll get to that in a second.
      </para>
    </sect3>

    <sect3>
      <title>Adding The Text</title>
      <para>
        Go ahead and remove the line to display the image (or comment
        it out with a (<code>;</code>) as the first character of the line).
      </para>
      <para>
        Before we add text to the image, we need to set the background
        and foreground colors so that the text appears in the color
        the user specified. We'll use the
        gimp-context-set-back/foreground functions:
      </para>
      <programlisting>
        (gimp-context-set-background '(255 255 255) )
        (gimp-context-set-foreground inTextColor)
      </programlisting>
      <para>
        With the colors properly set, let's now clean out the garbage
        currently in the image by filling the drawable with the background
        color:
      </para>
      <programlisting>
        (gimp-drawable-fill theLayer FILL-BACKGROUND)
      </programlisting>
      <para>With the image cleared, we're ready to add some text:</para>
      <programlisting>
        (set! theText
                      (car
                           (gimp-text-font
                            theImage theLayer
                            0 0
                            inText
                            0
                            TRUE
                            inFontSize
                            inFont)
                       )
        )
      </programlisting>
      <para>
        Although a long function call, it's fairly straightforward if
        you go over the parameters while looking at the function's
        entry in the DB Browser. Basically, we're creating a new text
        layer and assigning it to the variable
        <varname>theText</varname>.
      </para>
      <para>
        Now that we have the text, we can grab its width and height and resize
        the image and the image's layer to the text's size:
      </para>
      <programlisting>
        (set! theImageWidth   (car (gimp-drawable-get-width  theText) ) )
        (set! theImageHeight  (car (gimp-drawable-get-height theText) ) )

        (gimp-image-resize theImage theImageWidth theImageHeight 0 0)

        (gimp-layer-resize theLayer theImageWidth theImageHeight 0 0)
      </programlisting>
      <para>
        If you're like me, you're probably wondering what a drawable is when
        compared to a layer. The difference between the two is that a drawable
        is anything that can be drawn into, including layers but also
        channels, layer masks, the selection, etc; a layer is a more specific
        version of a drawable. In most cases, the distinction is not
        important.
      </para>
      <para>
        With the image ready to go, we can now re-add our display line:
      </para>
      <programlisting>
        (gimp-display-new theImage)
      </programlisting>
      <para>
        Save your work, restart <acronym>GIMP</acronym> and give your first
        script a run!
      </para>
    </sect3>

    <sect3>
      <title>Clearing The Dirty Flag</title>
      <para>
        If you try to close the image created without first saving the file,
        <acronym>GIMP</acronym> will ask you if you want to save your work
        before you close the
        image. It asks this because the image is marked as dirty, or unsaved.
        In the case of our script, this is a nuisance for the times when we
        simply give it a test run and don't add or change anything in the
        resulting image &mdash; that is, our work is easily reproducible in
        such a simple script, so it makes sense to get rid of this dirty flag.
      </para>
      <para>
        To do this, we can clear the dirty flag after displaying the image:
      </para>
      <programlisting>
        (gimp-image-clean-all theImage)
      </programlisting>
      <para>
        This will set dirty count to 0, making it appear to be a
        <quote>clean</quote> image.
      </para>
      <para>
        Whether to add this line or not is a matter of personal taste. I use
        it in scripts that produce new images, where the results are trivial,
        as in this case. If your script is very complicated, or if it works on
        an existing image, you will probably not want to use this function.
      </para>
    </sect3>
  </sect2>

  <sect2 id="gimp-using-script-fu-tutorial-extending-text-box">
    <title>Extending The Text Box Script</title>
    <sect3>
      <title>Handling Undo Correctly</title>
      <para>
        When creating a script, you want to give your users the ability to
        undo their actions, should they make a mistake. This is easily
        accomplished by calling the functions
        <function>gimp-image-undo-group-start</function>
        and <function>gimp-image-undo-group-end</function>
        around the code that manipulates the image. You can think of them as
        matched statements that let <acronym>GIMP</acronym> know when to start
        and stop recording manipulations on the image, so that those
        manipulations can later be undone.
      </para>
      <para>
        If you are creating a new image entirely, it doesn't make sense to use
        these functions because you're not changing an existing image.
        However, when you are changing an existing image, you most surely want
        to use these functions.
      </para>
      <para>
        Undoing a script works nearly flawlessly when using these functions.
      </para>
    </sect3>

    <sect3>
      <title>Extending The Script A Little More</title>
      <para>
        Now that we have a very handy-dandy script to create text
        boxes, let's add two features to it:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Currently, the image is resized to fit exactly around the
            text &mdash; there's no room for anything, like drop shadows or
            special effects (even though many scripts will automatically
            resize the image as necessary). Let's add a buffer around
            the text, and even let the user specify how much buffer to
            add as a percentage of the size of the resultant text.
          </para>
        </listitem>
        <listitem>
          <para>
            This script could easily be used in other scripts that work
            with text. Let's extend it so that it returns the image and
            the layers, so other scripts can call this script and use
            the image and layers we create.
          </para>
        </listitem>
      </itemizedlist>
    </sect3>

    <sect3>
      <title>
        Modifying The Parameters And The Registration Function
      </title>
      <para>
        To let the user specify the amount of buffer, we'll add a parameter to
        our function and the registration function:
      </para>
      <programlisting>
  (define (script-fu-text-box inTest inFont inFontSize inTextColor inBufferAmount)
  (let*
        (
           ; define our local variables
           ; create a new image:
           (theImageWidth  10)
           (theImageHeight 10)
           (theImage (car
                          (gimp-image-new
                           theImageWidth
                           theImageHeight
                           RGB
                          )
                     )
           )
           (theText)          ;a declaration for the text
                              ;we create later

           (theBuffer)        ;<emphasis>added</emphasis>

           (theLayer
                     (car
                         (gimp-layer-new
                          theImage
                           "layer 1"
                          theImageWidth
                          theImageHeight
                          RGB-IMAGE
                          100
                          LAYER-MODE-NORMAL
                         )
                     )
           )
        ) ;end of our local variables

   <replaceable>[Code here]</replaceable>
 )
      </programlisting>
      <programlisting><![CDATA[
  (script-fu-register
    "script-fu-text-box"                        ;function name
    "Text Box"                                  ;menu label
    "Creates a simple text box, sized to fit\
      around the user's choice of text,\
      font, font size, and color."              ;description
    "Michael Terry"                             ;author
    "copyright 1997, Michael Terry;\
      2009, the GIMP Documentation Team"        ;copyright notice
    "October 27, 1997"                          ;date created
    ""                                      ;image type that the script works on
    SF-STRING      "Text"          "Text Box"   ;a string variable
    SF-FONT        "Font"          "Charter"    ;a font variable
    SF-ADJUSTMENT  "Font size"     '(50 1 1000 1 10 0 1)
                                                ;a spin-button
    SF-COLOR       "Color"         '(0 0 0)     ;color variable
    SF-ADJUSTMENT  "Buffer amount" '(35 0 100 1 10 1 0)
                                                ;a slider
  )
  (script-fu-menu-register "script-fu-text-box" "<Image>/Filters/Tutorial")
      ]]></programlisting>
    </sect3>

    <sect3>
      <title>Adding The New Code</title>
      <para>
        We're going to add code in two places: right before we resize
        the image, and at the end of the script (to return the new
        image, the layer and the text).
      </para>
      <para>
        After we get the text's height and width, we need to resize
        these values based on the buffer amount specified by the
        user. We won't do any error checking to make sure it's in the
        range of 0-100% because it's not life-threatening, and because
        there's no reason why the user can't enter a value like
        <quote>200</quote> as the percent of buffer to add.
      </para>
      <programlisting>
        (set! theBuffer (* theImageHeight (/ inBufferAmount 100) ) )

        (set! theImageHeight (+ theImageHeight theBuffer theBuffer) )
        (set! theImageWidth  (+ theImageWidth  theBuffer theBuffer) )
      </programlisting>
      <para>
        All we're doing here is setting the buffer based on the height of the
        text, and adding it twice to both the height and width of our new
        image. (We add it twice to both dimensions because the buffer needs to
        be added to both sides of the text.)
      </para>
      <para>
        Now that we have resized the image to allow for a buffer, we
        need to center the text within the image. This is done by
        moving it to the (x, y) coordinates of (<varname>theBuffer</varname>,
        <varname>theBuffer</varname>). I added this line after
        resizing the layer and the image:
      </para>
      <programlisting>
        (gimp-layer-set-offsets theText theBuffer theBuffer)
      </programlisting>
      <para>
        Go ahead and save your script, and try it out after restarting
        <acronym>GIMP</acronym>.
      </para>
      <para>
        All that is left to do is return our image, the layer, and the text
        layer. After displaying the image, we add this line:
      </para>
      <programlisting>(list theImage theLayer theText)</programlisting>
      <para>
        This is the last line of the function, making this list available to
        other scripts that want to use it.
      </para>
      <para>
        To use our new text box script in another script, we could write
        something like the following:
      </para>
      <programlisting>
        (set! theResult (script-fu-text-box
                         "Some text"
                         "Charter" "30"
                         '(0 0 0)
                         "35"
                        )
        )
        (gimp-image-flatten (car theResult))
      </programlisting>
      <para>
        Congratulations, you are on your way to your Black Belt of Script-Fu!
      </para>
    </sect3>
  </sect2>

  <sect2 id="gimp-using-script-fu-tutorial-result">
    <title>Your script and its working</title>
    <sect3>
      <title>What you write</title>
      <para>Below the complete script:</para>
      <programlisting><![CDATA[
  (script-fu-register
            "script-fu-text-box"                        ;function name
            "Text Box"                                  ;menu label
            "Creates a simple text box, sized to fit\
              around the user's choice of text,\
              font, font size, and color."              ;description
            "Michael Terry"                             ;author
            "copyright 1997, Michael Terry;\
              2009, the GIMP Documentation Team"        ;copyright notice
            "October 27, 1997"                          ;date created
            ""                              ;image type that the script works on
            SF-STRING      "Text"          "Text Box"   ;a string variable
            SF-FONT        "Font"          "Charter"    ;a font variable
            SF-ADJUSTMENT  "Font size"     '(50 1 1000 1 10 0 1)
                                                        ;a spin-button
            SF-COLOR       "Color"         '(0 0 0)     ;color variable
            SF-ADJUSTMENT  "Buffer amount" '(35 0 100 1 10 1 0)
                                                        ;a slider
  )
  (script-fu-menu-register "script-fu-text-box" "<Image>/Filters/Tutorial")
  (define (script-fu-text-box inText inFont inFontSize inTextColor inBufferAmount)
    (let*
      (
        ; define our local variables
        ; create a new image:
        (theImageWidth  10)
        (theImageHeight 10)
        (theImage)
        (theImage
                  (car
                      (gimp-image-new
                        theImageWidth
                        theImageHeight
                        RGB
                      )
                  )
        )
        (theText)             ;a declaration for the text
        (theBuffer)           ;create a new layer for the image
        (theLayer
                  (car
                      (gimp-layer-new
                        theImage
                        "layer 1"
                        theImageWidth
                        theImageHeight
                        RGB-IMAGE
                        100
                        LAYER-MODE-NORMAL
                      )
                  )
        )
      ) ;end of our local variables
      (gimp-image-insert-layer theImage theLayer 0 0)
      (gimp-context-set-background '(255 255 255) )
      (gimp-context-set-foreground inTextColor)
      (gimp-drawable-fill theLayer FILL-BACKGROUND)
      (set! theText
                    (car
                          (gimp-text-font
                          theImage theLayer
                          0 0
                          inText
                          0
                          TRUE
                          inFontSize
                          inFont)
                      )
        )
      (set! theImageWidth   (car (gimp-drawable-get-width  theText) ) )
      (set! theImageHeight  (car (gimp-drawable-get-height theText) ) )
      (set! theBuffer (* theImageHeight (/ inBufferAmount 100) ) )
      (set! theImageHeight (+ theImageHeight theBuffer theBuffer) )
      (set! theImageWidth  (+ theImageWidth  theBuffer theBuffer) )
      (gimp-image-resize theImage theImageWidth theImageHeight 0 0)
      (gimp-layer-resize theLayer theImageWidth theImageHeight 0 0)
      (gimp-layer-set-offsets theText theBuffer theBuffer)
      (gimp-floating-sel-to-layer theText)
      (gimp-display-new theImage)
      (list theImage theLayer theText)
    )
  )
      ]]></programlisting>
    </sect3>

    <sect3>
      <title>What you obtain</title>
      <figure>
        <title>The dialog</title>
        <mediaobject>
          <imageobject>
            <imagedata format="PNG"
              fileref="images/using/script-fu-example-dialog.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <figure>
        <title>The resulting image</title>
        <mediaobject>
          <imageobject>
            <imagedata format="PNG"
              fileref="images/using/script-fu-example-result.png"/>
          </imageobject>
        </mediaobject>
      </figure>
    </sect3>
  </sect2>
</sect1>
