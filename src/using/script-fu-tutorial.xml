<?xml version='1.0' encoding="UTF-8" ?>

<sect1 id='gimp-using-script-fu-tutorial' lang="en">
  <title lang="en">A Script-Fu Tutorial</title>

  <para lang="en">
    In this training course, we'll introduce you to the fundamentals
    of Scheme necessary to use Script-Fu, and then build a handy
    script that you can add to your toolbox of scripts. The script
    prompts the user for some text, then creates a new image sized
    perfectly to the text. We will then enhance the script to allow
    for a buffer of space around the text. We will conclude with a few
    suggestions for ways to ramp up your knowledge of Script-Fu. 
  </para>

  <note>
    <para>
      This section as adapted from a tutorial written for the Gimp 1 User
      Manual by Mike Terry.
    </para>
  </note>

  <sect2>
    <title lang='en'>Getting Acquainted With Scheme</title>
    <simplesect>
      <title lang='en'>Let's Start Scheme'ing</title>
      <para lang='en'>	
        The first thing to learn is that:
      </para>
      <para><emphasis role='bold'>
        Every statement in Scheme is surrounded by parentheses ().
      </emphasis></para>
      <para>
        The second thing you need to know is that:
      </para>
      <para><emphasis role='bold'>
        The function name/operator is always the first item in the
        parentheses, and the rest of the items are parameters to the
        function. 
      </emphasis></para>
      <para>
        However, not everything enclosed in parentheses is a function --
        they can also be items in a list -- but we'll get to that
        later. This notation is referred to as prefix notation, because
        the function prefixes everything else. If you're familiar with
        postfix notation, or own a calculator that uses Reverse Polish
        Notation (such as most HP calculators), you should have no
        problem adapting to formulating expressions in Scheme. 
      </para>
      <para>
        The third thing to understand is that:
      </para>
      <para><emphasis role='bold'>
        Mathematical operators are also considered functions, and thus
        are listed first when writing mathematical expressions. 
      </emphasis></para>
      <para>
        This follows logically from the prefix notation that we just
        mentioned. 
      </para>
    </simplesect>

    <simplesect>
      <title lang='en'>Examples Of Prefix, Infix, And Postfix Notations</title>
      <para lang='en'>
        Here are some quick examples illustrating the differences
        between <emphasis>prefix</emphasis>,
        <emphasis>infix</emphasis>, and <emphasis>postfix</emphasis>
        notations. We'll add a 1 and 3 together: 
      </para>
      <itemizedlist lang='en'>
        <listitem><para>
          Prefix notation: + 1 3 (the way Scheme will want it)
        </para></listitem>
        <listitem><para>
          Infix notation: 1 + 3 (the way we "normally" write it)
        </para></listitem>
        <listitem><para>
          Postfix notation: 1 3 + (the way many HP calculators will
          want it)
        </para></listitem>
      </itemizedlist>
    </simplesect>

    <simplesect>
      <title lang='en'>Practicing In Scheme</title>
      <para lang='en'>
        Now, let's practice what we have just learned. Start up Gimp,
        if you have not already done so, and choose
        Xtns/Script-Fu/Console. This will start up the Script-Fu
        Console window, which allows us to work interactively in
        Scheme. In a matter of moments, the Script-Fu Console will
        appear: 
      </para>
    </simplesect>

    <simplesect>
      <title lang='en'>The Script-Fu Console Window</title>
      <para lang='en'>
        At the bottom of this window is an entry-field entitled
        Current Command. Here, we can test out simple Scheme commands
        interactively. Let's start out easy, and add some numbers: 
      </para>
      <programlisting>
        (+ 3 5)
      </programlisting>
      <para>
        Typing this in and hitting Return yields the expected answer
        of 8 in the center window. 
      </para>
      <para>
        Now, what if we wanted to add more than one number? The "+"
        function can take two or more arguments, so this is not a
        problem: 
      </para>
      <programlisting>
        (+ 3 5 6)
      </programlisting>
      <para>
        This also yields the expected answer of 14.
      </para>
      <para>
        So far, so good -- we type in a Scheme statement and it's
        executed immediately in the Script-Fu Console window. Now for
        a word of caution.... 
      </para>
    </simplesect>

    <simplesect>
      <title lang='en'>Watch Out For Extra Parens</title>
      <para lang='en'>
        If you're like me, you're used to being able to use extra
        parentheses whenever you want to -- like when you're typing a
        complex mathematical equation and you want to separate the
        parts by parentheses to make it clearer when you read it. In
        Scheme, you have to be careful and not insert these extra
        parentheses incorrectly. For example, say we wanted to add 3
        to the result of adding 5 and 6 together: 
      </para>
      <programlisting>
        3 + (5 + 6) + 7= ?
      </programlisting>
      <para>
        Knowing that the + operator can take a list of numbers to add,
        you might be tempted to convert the above to the following: 
      </para>
      <programlisting>
        (+ 3 (5 6) 7)
      </programlisting>
      <para>
        However, this is incorrect -- remember, every statement in
        Scheme starts and ends with parens, so the Scheme interpreter
        will think that you're trying to call a function named "5" in
        the second group of parens, rather than summing those numbers
        before adding them to 3. 
      </para>
      <para>
        The correct way to write the above statement would be:
      </para>
      <programlisting>
        (+ 3 (+ 5 6) 7)
      </programlisting>
    </simplesect>

    <simplesect>
      <title lang='en'>Make Sure You Have The Proper Spacing, Too</title>
      <para lang='en'>
        If you are familiar with other programming languages, like
        C/C++, Perl or Java, you know that you don't need white space
        around mathematical operators to properly form an expression: 
      </para>
      <programlisting>
        <literal>3+5, 3 +5, 3+ 5</literal>
      </programlisting>
      <para>
        These are all accepted by C/C++, Perl and Java
        compilers. However, the same is not true for Scheme. You must
        have a space after a mathematical operator (or any other
        function name or operator) in Scheme for it to be correctly
        interpreted by the Scheme interpreter. 
      </para>
      <para>
        Practice a bit with simple mathematical equations in the
        Script-Fu Console until you're totally comfortable with these
        initial concepts. 
      </para>
    </simplesect>
  </sect2>

  <sect2>
    <title lang='en'>Variables And Functions</title>
    <para lang='en'>
      Now that we know that every Scheme statement is enclosed in
      parentheses, and that the function name/operator is listed first,
      we need to know how to create and use variables, and how to create
      and use functions. We'll start with the variables. 
    </para>

    <simplesect>
      <title lang='en'>Declaring Variables</title>
      <para lang='en'>
        Although there are a couple of different methods for declaring
        variables, the preferred method is to use the let*
        construct. If you're familiar with other programming
        languages, this construct is equivalent to defining a list of
        local variables and a scope in which they're active. As an
        example, to declare two variables, a and b, initialized to 1
        and 2, respectively, you'd write: 
      </para>
      <programlisting>
         (let*  (
                   (a 1)
                   (b 2)
                )
                (+ a b)
         )
      </programlisting>
      <para>
        or, as one line:
      </para>
      <programlisting>
        (let* ( (a 1) (b 2) ) (+ a b) )
      </programlisting>
      <note>
	<para>
	  You'll have to put all of this on one line if you're using the
	  console window. In general, however, you'll want to adopt a
	  similar practice of indentation to help make your scripts more
	  readable. We'll talk a bit more about this in the section on
	  White Space. 
	</para>
      </note>
      <para>
        This declares two local variables, a and b, initializes them,
        then prints the sum of the two variables. 
      </para>
    </simplesect>

    <simplesect>
      <title lang='en'>What Is A Local Variable?</title>
      <para lang='en'>
        You'll notice that we wrote the summation <code>(+ a b)</code>
        within the parens of the <code>let*</code> expression, not after it. 
      </para>
      <para>
        This is because the <code>let*</code> statement defines an
        area in your script in which the declared variables are
        usable; if you type the (+ a b) statement after the (let* ...)
        statement, you'll get an error, because the declared variables
        are only valid within the context of the <code>let*</code> statement; they
        are what programmers call local variables. 
      </para>
    </simplesect>

    <simplesect>
      <title lang='en'>The General Syntax Of <code>let*</code></title>
      <para lang='en'>
        The general form of a <code>let*</code> statement is:
      </para>
      <programlisting>
        (let* ( <replaceable>variables</replaceable> ) <replaceable>expressions</replaceable> )
      </programlisting>
      <para>
        where variables are declared within parens, e.g., (a 2), and
        expressions are any valid Scheme expressions. Remember that
        the variables declared here are only valid within the
        <code>let*</code> statement -- they're local variables. 
      </para>
    </simplesect>

    <simplesect>
      <title lang='en'>White Space</title>
      <para lang='en'>
        Previously, we mentioned the fact that you'll probably want to
        use indentation to help clarify and organize your
        scripts. This is a good policy to adopt, and is not a problem
        in Scheme -- white space is ignored by the Scheme interpreter,
        and can thus be liberally applied to help clarify and organize
        the code within a script. However, if you're working in
        Script-Fu's Console window, you'll have to enter an entire
        expression on one line; that is, everything between the
        opening and closing parens of an expression must come on one
        line in the Script-Fu Console window. 
      </para>
    </simplesect>

    <simplesect>
      <title lang='en'>Assigning A New Value To A Variable</title>
      <para lang='en'>
        Once you've initialized a variable, you might need to change
        its value later on in the script. Use the set! statement to
        change the variable's value: 
      </para>
      <programlisting>
        (let* ( (theNum 10) ) (set! theNum (+ theNum \ theNum)) )
      </programlisting>
      <para>
        Try to guess what the above statement will do, then go ahead
        and enter it in the Script-Fu Console window. 
      </para>
      <note>
	<para>
	  The "\" indicates that there is no line break. Ignore it (don't
	  type it in your Script-Fu console and don't hit Enter), just
	  continue with the next line. 
	</para>
      </note>
    </simplesect>

    <simplesect>
      <title lang='en'>Functions</title>
      <para lang='en'>
        Now that you've got the hang of variables, let's get to work
        with some functions. You declare a function with the following
        syntax: 
      </para>
      <programlisting>
        (define (<replaceable>name</replaceable> <replaceable>param-list</replaceable>) <replaceable>expressions</replaceable>)
      </programlisting>
      <para>
        where <replaceable>name</replaceable> is the name assigned to
        this function, <replaceable>param-list</replaceable> is a
        space-delimited list of parameter names, and
        <replaceable>expressions</replaceable> is a series of
        expressions that the function executes when it's called. For
        example:  
      </para>
      <programlisting>
        (define (AddXY inX inY) (+ inX inY) )
      </programlisting>
      <para>
        <varname>AddXY</varname> is the function's name and
        <varname>inX</varname> and <varname>inY</varname> are the
        variables. This function takes its two parameters and adds
        them together. 
      </para>
      <para>
        If you've programmed in other imperative languages (like
        C/C++, Java, Pascal, etc.), you might notice that a couple of
        things are absent in this function definition when compared to
        other programming languages. 
      </para>
      <itemizedlist>
        <listitem><para>
          First, notice that the parameters don't have any "types"
          (that is, we didn't declare them as strings, or integers,
          etc.). Scheme is a type-less language. This is handy and
          allows for quicker script writing. 
        </para></listitem>
        <listitem><para>
            Second, notice that we don't need to worry about how to
            "return" the result of our function -- the last statement is
            the value "returned" when calling this function. Type the
            function into the console, then try something like:
          </para>
          <programlisting>
            (AddXY (AddXY 5 6) 4)
          </programlisting>
        </listitem>
      </itemizedlist>
    </simplesect>
  </sect2>

  <sect2>
    <title lang='en'>Lists, Lists And More Lists</title>
    <para lang='en'>
      We've trained you in variables and functions, and now enter the
      murky swamps of Scheme's lists. 
    </para>

    <simplesect>
      <title lang='en'>Defining A List</title>
      <para lang='en'>
        Before we talk more about lists, it is necessary that you know
        the difference between atomic values and lists.  
      </para>
      <para>
        You've already seen atomic values when we initialized
        variables in the previous lesson. An atomic value is a single
        value. So, for example, we can assign the variable "x" the
        single value of 8 in the following statement: 
      </para>
      <programlisting>
        (let* ( (x 8) ) x)
      </programlisting>
      <para>
        (We added the expression <varname>x</varname> at the end to print out the value
        assigned to <varname>x</varname>-- normally you won't need to do this. Notice how
        <code>let*</code> operates just like a function: The value of
        the last statement is the value returned.) 
      </para>
      <para>
        A variable may also refer to a list of values, rather than a
        single value. To assign the variable <varname>x</varname> the
        list of values 1, 3, 5, we'd type: 
      </para>
      <programlisting>
        (let* ( (x '(1 3 5))) x)
      </programlisting>
      <para>
        Try typing both statements into the Script-Fu Console and
        notice how it replies. When you type the first statement in,
        it simply replies with the result: 
      </para>
      <programlisting>
        8
      </programlisting>
      <para>
        However, when you type in the other statement, it replies with
        the following result: 
      </para>
      <programlisting>
        (1 3 5)
      </programlisting>
      <para>
         When it replies with the value 8 it is informing you that
         <varname>x</varname> contains the atomic value 8. However,
         when it replies with (1 3 5), it is then informing you that
         <varname>x</varname> contains not a single value, but a list
         of values. Notice that there are no commas in our declaration
         or assignment of the list, nor in the printed result. 
      </para>
      <para>
         The syntax to define a list is:
      </para>
      <programlisting>
         '(a b c)
      </programlisting>
      <para>
        where <varname>a</varname>, <varname>b</varname>, and
        <varname>c</varname> are literals. We use the apostrophe (')
        to indicate that what follows in the parentheses is a list of
        literal values, rather than a function or expression. 
      </para>
      <para>
        An empty list can be defined as such:
      </para>
      <programlisting>
        '()
      </programlisting>
      <para>
        or simply:
      </para>
      <programlisting>
        ()
      </programlisting>
      <para>
        Lists can contain atomic values, as well as other lists:
      </para>
      <programlisting>
        (let*
           (
                (x 
                   '("The Gimp" (1 2 3) ("is" ("great" () ) ) )
                )
            )       
                
            x
         )
      </programlisting>
      <para>
        Notice that after the first apostrophe, you no longer need to
        use an apostrophe when defining the inner lists. Go ahead and
        copy the statement into the Script-Fu Console and see what it
        returns. 
      </para>
      <para>
        You should notice that the result returned is not a list of
        single, atomic values; rather, it is a list of a literal <code>("The
        Gimp")</code>, the list <code>(1 2 3)</code>, etc.
      </para>
    </simplesect>

    <simplesect>
      <title lang='en'>How To Think Of Lists</title>
      <para lang='en'>
        It's useful to think of lists as composed of a "head" and a
        "tail." The head is the first element of the list, the tail
        the rest of the list. You'll see why this is important when we
        discuss how to add to lists and how to access elements in the
        list. 
      </para>
    </simplesect>

    <simplesect>
      <title lang='en'>Creating Lists Through Concatenation (The Cons Function)</title>
      <para lang='en'>
        One of the more common functions you'll encounter is the cons
        function. It takes a value and prepends it to its second
        argument, a list. From the previous section, I suggested that
        you think of a list as being composed of an element (the head)
        and the remainder of the list (the tail). This is exactly how
        cons functions -- it adds an element to the head of a
        list. Thus, you could create a list as follows: 
      </para>
      <programlisting>
        (cons 1 '(2 3 4) )
      </programlisting>
      <para>
        The result is the list <code>(1 2 3 4)</code>.
      </para>
      <para>
        You could also create a list with one element:
      </para>
      <programlisting>
        (cons 1 () )
      </programlisting>
      <para>
        You can use previously declared variables in place of any
        literals, as you would expect. 
      </para>
    </simplesect>

    <simplesect>
      <title lang='en'>Defining A List Using The list Function</title>
      <para lang='en'>
        To define a list composed of literals or previously declared
        variables, use the list function: 
      </para>
      <programlisting>
        (list 5 4 3 a b c)
      </programlisting>
      <para>
        This will compose and return a list containing the values held
        by the variables <varname>a</varname>, <varname>b</varname>
        and <varname>c</varname>. For example:  
      </para>
      <programlisting>
        (let*  (
                  (a 1)
                  (b 2)
                  (c 3)
               )
               (list 5 4 3 a b c)
        )
      </programlisting>  	
      <para>
        This code creates the list <code>(5 4 3 1 2 3)</code>.
      </para>
    </simplesect>

    <simplesect>
      <title lang='en'>Accessing Values In A List</title>
      <para lang='en'>
        To access the values in a list, use the functions <code>car</code> and <code>cdr</code>,
        which return the first element of the list and the rest of the
        list, respectively. These functions break the list down into
        the head::tail construct I mentioned earlier. 
      </para>
    </simplesect>

    <simplesect>
      <title lang='en'>The <code>car</code> Function</title>
      <para lang='en'>
        <code>car</code> returns the first element of the list (the
        head of the list). The list needs to be non-null. Thus, the
        following returns the first element of the list: 
      </para>
      <programlisting>
        (car '("first" 2 "third"))
      </programlisting>  	
      <para>
        which is:
      </para>
      <programlisting>
        "first"
      </programlisting>  	
    </simplesect>

    <simplesect>
      <title lang='en'>The <code>cdr</code> function</title>
      <para lang='en'>
        <code>cdr</code> returns the rest of the list after the first
        element (the tail of the list). If there is only one element
        in the list, it returns an empty list. 
      </para>
      <programlisting>
        (cdr '("first" 2 "third"))
      </programlisting>  	
      <para>
        returns:
      </para>
      <programlisting>
        (2 "third")
      </programlisting>  	
      <para>
        whereas the following:
      </para>
      <programlisting>
        (cdr '("one and only"))
      </programlisting>  	
      <para>
        returns:
      </para>
      <programlisting>
        ()
      </programlisting>  	
    </simplesect>

    <simplesect>
      <title lang='en'>Accessing Other Elements In A List</title>
      <para lang='en'>
        OK, great, we can get the first element in a list, as well as
        the rest of the list, but how do we access the second, third
        or other elements of a list? There exist several "convenience"
        functions to access, for example, the head of the head of the
        tail of a list (<code>caadr</code>), the tail of the tail of a
        list (<code>cddr</code>), etc. 
      </para>
      <para>
        The basic naming convention is easy: The a's and d's represent
        the heads and tails of lists, so 
      </para>
      <programlisting>
        (car (cdr (car x) ) )
      </programlisting>  	
      <para>
        could be written as:
      </para>
      <programlisting>
        (cadar x)
      </programlisting>  	
      <para>
        To view a full list of the list functions, refer to the
        Appendix, which lists the available functions for the version
        of Scheme used by Script-Fu. 
      </para>
      <para>
        To get some practice with list-accessing functions, try typing
        in the following (except all on one line if you're using the
        console); use different variations of car and cdr to access
        the different elements of the list: 
      </para>
      <programlisting>
        (let* (
                 (x  '( (1 2 (3 4 5) 6)  7  8  (9 10) )
                 )
              )
              ; place your car/cdr code here
        )
      </programlisting>
      <para>
        Try accessing the number 3 in the list using only two function
        calls. If you can do that, you're on your way to becoming a
        Script-Fu Master! 
      </para>
      <note>
	<para>
	  In Scheme, a semicolon (";") marks a comment.  It, and
	  anything that follows it on the same line, are ignored by the
	  script interpreter, so you can use this to add comments to jog
	  your memory when you look at the script later.
	</para>
      </note>
    </simplesect>
  </sect2>  	

  <sect2>
    <title lang='en'>Your First Script-Fu Script</title>
    <para lang='en'>
      Do you not need to stop and catch your breath? No? Well then,
      let's proceed with your fourth lesson -- your first Script-Fu
      Script. 
    </para>

    <simplesect>
      <title lang='en'>Creating A Text Box Script</title>
      <para lang='en'>
        One of the most common operations I perform in Gimp is
        creating a box with some text in it for a web page, a logo or
        whatever. However, you never quite know how big to make the
        initial image when you start out. You don't know how much
        space the text will fill with the font and font size you
        want. 
      </para>
      <para>
        The Script-Fu Master (and student) will quickly realize that
        this problem can easily be solved and automated with
        Script-Fu. 
      </para>
      <para>
        We will, therefore, create a script, called Text Box, which
        creates an image correctly sized to fit snugly around a line
        of text the user inputs. We'll also let the user choose the
        font, font size and text color. 
      </para>
    </simplesect>

    <simplesect>
      <title lang='en'>Editing And Storing Your Scripts</title>
      <para lang='en'>
        Up until now, we've been working in the Script-Fu
        Console. Now, however, we're going to switch to editing script
        text files. 
      </para>
      <para>
        Where you place your scripts is a matter of preference -- if
        you have access to Gimp's default script directory, you can
        place your scripts there. However, I prefer keeping my
        personal scripts in my own script directory, to keep them
        separate from the factory-installed scripts. 
      </para>
      <para>
        In the <filename>.gimp-2.2</filename> directory that Gimp made
        off of your home directory, you should find a directory called
        <filename>scripts</filename>. Gimp will automatically look in
        your <filename>.gimp-2.2</filename> directory for a scripts
        directory, and add the 
        scripts in this directory to the Script-Fu database. You
        should place your personal scripts here. 
      </para>
    </simplesect>

    <simplesect>
      <title lang='en'>The Bare Essentials</title>
      <para lang='en'>
        Every Script-Fu script defines at least one function, which is
        the script's main function. This is where you do the work. 
      </para>
      <para>
        Every script must also register with the procedural database,
        so you can access it within Gimp. 
      </para>
      <para>
       We'll define the main function first:
      </para>
      <programlisting>
        (define (script-fu-text-box inText inFont inFontSize inTextColor))
      </programlisting>  	
      <para>
        Here, we've defined a new function called script-fu-text-box
        that takes four parameters, which will later correspond to
        some text, a font, the font size, and the text's color. The
        function is currently empty and thus does nothing. So far, so
        good -- nothing new, nothing fancy. 
      </para>
    </simplesect>

    <simplesect>
      <title lang='en'>Naming Conventions</title>
      <para lang='en'>
        Scheme's naming conventions seem to prefer lowercase letters
        with hyphens, which I've followed in the naming of the
        function. However, I've departed from the convention with the
        parameters. I like more descriptive names for my parameters
        and variables, and thus add the "in" prefix to the parameters
        so I can quickly see that they're values passed into the
        script, rather than created within it. I use the prefix "the"
        for variables defined within the script. 
      </para>
      <para>
        It's Gimp convention to name your script functions
        script-fu-abc, because then when they're listed in the
        procedural database, they'll all show up under script-fu when
        you're listing the functions. This also helps distinguish them
        from plug-ins. 
      </para>
    </simplesect>

    <simplesect>
      <title lang='en'>Registering The Function</title>
      <para lang='en'>
        Now, let's register the function with Gimp. This is done by
        calling the function <code>script-fu-register</code>. When
        Gimp reads in a 
        script, it will execute this function, which registers the
        script with the procedural database. You can place this
        function call wherever you wish in your script, but I usually
        place it at the end, after all my other code. 
      </para>
      <para>
        Here's the listing for registering this function (I will
        explain all its parameters in a minute): 
      </para>
      <programlisting>
<![CDATA[
        (script-fu-register
          "script-fu-text-box"                        ;func name
          "Text Box"                                  ;menu label
          "Creates a simple text box, sized to fit\
            around the user's choice of text,\
            font, font size, and color."              ;description
          "Michael Terry"                             ;author
          "copyright 1997, Michael Terry"             ;copyright notice
          "October 27, 1997"                          ;date created
          ""                     ;image type that the script works on
          SF-STRING      "Text:"         "Text Box"   ;a string variable
          SF-FONT        "Font:"         "Charter"    ;a font variable
          SF-ADJUSTMENT  "Font size"     '(50 1 1000 1 10 0 1)
                                                      ;a spin-button
          SF-COLOR       "Color:"        '(0 0 0)     ;color variable
        )
        (script-fu-menu-register "script-fu-text-box" "<Toolbox>/Xtns/Script-Fu/Text")
]]>
      </programlisting>
      <para>
        If you save these functions in a text file with a
        <filename>.scm</filename> suffix
        in your script directory, then choose
        <menuchoice>
          <guimenu>Xtns</guimenu>
          <guisubmenu>Script-Fu</guisubmenu>
          <guimenuitem>Refresh</guimenuitem>
        </menuchoice>,
        this new script will appear as
        <menuchoice>
          <guimenu> Xtns</guimenu>
          <guisubmenu>Script-Fu</guisubmenu>
          <guisubmenu>Text</guisubmenu>
          <guimenuitem>Text Box</guimenuitem>
        </menuchoice>. 
      </para>
      <para>
        If you invoke this new script, it won't do anything, of
        course, but you can view the prompts you created when
        registering the script (more information about what we did is
        covered next). 
      </para>
      <para>
        Finally, if you invoke the Procedure Browser -- 
        <menuchoice>
          <guimenu> Xtns</guimenu>
          <guimenuitem>Procedure Browser</guimenuitem>
        </menuchoice>), 
        you'll notice that our script now
        appears in the database. 
      </para>
    </simplesect>

    <simplesect>
      <title lang='en'>Steps For Registering The Script</title>
      <para lang='en'>
        To register our script with Gimp, we call the function
        script-fu-register, fill in the seven required parameters and
        add our script's own parameters, along with a description and
        default value for each parameter.
      </para>
      <itemizedlist lang='en'>
        <title>The Required Parameters</title>

        <listitem><para>
          The <emphasis role='bold'>name</emphasis> of the function we
          defined. This is the function 
          called when our script is invoked (the entry-point into our
          script). This is necessary because we may define additional
          functions within the same file, and Gimp needs to know which
          of these functions to call. In our example, we only defined
          one function, text-box, which we registered. 
        </para></listitem>

        <listitem><para>
          The <emphasis role='bold'>location</emphasis> in the menu
          where the script will be 
          inserted. The exact location of the script is specified like a
          path in Unix, with the root of the path being either toolbox
          or right-click. 
        </para></listitem>

        <listitem><para>
            If your script does not operate on an existing image (and
            thus creates a new image, like our Text Box script will),
            you'll want to insert it in the toolbox menu -- this is the
            menu in Gimp's main window (where all the tools are located:
            the selection tools, magnifying glass, etc.). 
          </para>
          <para>
            If your script is intended to work on an image being edited,
            you'll want to insert it in the menu that appears when you
            right-click on an open image. The rest of the path points to
            the menu lists, menus and sub-menus. Thus, we registered our
            Text Box script in the Text menu of the Script-Fu menu of
            the Xtns menu of the toolbox (
            <menuchoice>
              <guimenu> Xtns</guimenu>
              <guisubmenu>Script-Fu</guisubmenu>
              <guisubmenu>Text</guisubmenu>
              <guimenuitem>Text Box</guimenuitem>
            </menuchoice> 
            ). 
          </para>
          <para>
            If you notice, the Text sub-menu in the Script-Fu menu
            wasn't there when we began -- Gimp automatically creates any
            menus not already existing. 
        </para></listitem>

        <listitem><para>
          A <emphasis role='bold'>description</emphasis> of your
          script, to be displayed in the Procedure Browser.
        </para></listitem>

        <listitem><para>
          <emphasis role='bold'>Your name</emphasis> (the author of
          the script). 
        </para></listitem>

        <listitem><para>
          <emphasis role='bold'>Copyright</emphasis> information.
        </para></listitem>

        <listitem><para>
           The <emphasis role='bold'>date</emphasis> the script was
           made, or the last revision of the script. 
        </para></listitem>

        <listitem><para>
          The <emphasis role='bold'>types</emphasis> of images the
          script works on. This may be any of the following: RGB,
          RGBA, GRAY, GRAYA, INDEXED, INDEXEDA. Or it may be none at
          all -- in our case, we're creating an image, and thus don't
          need to define the type of image on which we work. 
        </para></listitem>
      </itemizedlist>
    </simplesect>

    <simplesect>
      <title lang='en'>Registering The Script's Parameters</title>
      <para lang='en'>
        Once we have listed the required parameters, we then need to
        list the parameters that correspond to the parameters our
        script needs. When we list these params, we give hints as to
        what their types are. This is for the dialog which pops up
        when the user selects our script. We also provide a default
        value. 
      </para>
      <para>
        This section of the registration process has the following format:
      </para>
      <informaltable lang='en' rowsep='1' colsep='1' frame='all'>
        <tgroup cols='3'>
        <colspec colwidth='1in' />
        <colspec colwidth='3in' />
        <colspec colwidth='2in' />
        <thead>
          <row>
            <entry><para>Param Type</para></entry>
            <entry><para>Description</para></entry>
            <entry><para>Example</para></entry>
           </row>
        </thead>
        <tbody>
          <row>
            <entry><para>SF-VALUE</para></entry>
            <entry><para>
              Accepts numbers and strings. Note that quotes must be
              escaped for default text, so better use SF-STRING.
            </para></entry>
            <entry><para>42</para></entry>
          </row>
         
          <row>
            <entry><para>SF-STRING</para></entry>
            <entry><para>
              Accepts strings.
            </para></entry>
            <entry><para>"Some text"</para></entry>
          </row>

          <row>
            <entry><para>SF-COLOR</para></entry>
            <entry><para>
              Indicates that a color is requested in this parameter
            </para></entry>
            <entry><para>'(0 102 255)</para></entry>
          </row>

          <row>
            <entry><para>SF-TOGGLE</para></entry>
            <entry><para>
              A checkbox is displayed, to get a Boolean value.
            </para></entry>
            <entry><para>TRUE or FALSE</para></entry>
          </row>

          <row>
            <entry><para>SF-IMAGE</para></entry>
            <entry><para>
              If your script operates on an open image, this should be
              the first parameter after the required parameters. Gimp
              will pass in a reference to the image in this parameter. 
            </para></entry>
            <entry><para>3</para></entry>
          </row>

          <row>
            <entry><para>SF-DRAWABLE</para></entry>
            <entry><para>
              If your script operates on an open image, this should be
              the second parameter after the SF-IMAGE param. It refers
              to the active layer. Gimp will pass in a reference to the
              active layer in this parameter. 
            </para></entry>
            <entry><para>17</para></entry>
          </row>

        </tbody>
        </tgroup>
      </informaltable>
    </simplesect>
  </sect2>

  <sect2>
    <title lang='en'>Giving Our Script Some Guts</title>
    <para lang='en'>
      Let us continue with our training and add some functionality to
      our script. 
    </para>

    <simplesect>
      <title lang='en'>Creating A New Image</title>
      <para>
        In the previous lesson, we created an empty function and
        registered it with Gimp. In this lesson, we want to provide
        functionality to our script -- we want to create a new image,
        add the user's text to it and resize the image to fit the text
        exactly. 
      </para>
      <para>
        Once you know how to set variables, define functions and
        access list members, the rest is all downhill -- all you need
        to do is familiarize yourself with the functions available in
        Gimp's procedural database and call those functions
        directly. So fire up the DB Browser and let's get cookin'! 
      </para>
      <para>
        Let's begin by making a new image. We'll create a new
        variable, <varname>theImage</varname>, set to the result of calling Gimp's
        built-in function <code>gimp-image-new</code>. 
      </para>
      <para>
  	As you can see from the DB Browser, the function
  	<code>gimp-image-new</code> takes three parameters -- the
  	image's width, height and the type of image. Because we'll
  	later resize the image to fit the text, we'll make a 10x10 RGB
  	image. We'll store the image's width and sizes in some
  	variables, too, as we'll refer to and manipulate them later in
  	the script. 
      </para>
      <programlisting>
        (define (script-fu-text-box inText inFont inFontSize inTextColor)
        (let*
              (
                 ; define our local variables
                 ; create a new image:
                 (theImageWidth  10)
                 (theImageHeight 10)
                 (theImage (car 
                                (gimp-image-new
                                 theImageWidth
                                 theImageHeight
                                 RGB
                                )
                           )
                 )
                 (theText)     ;a declaration for the text
                               ;we create later
      </programlisting>
      <para>
        Note: We used the value RGB to specify that the image is an
        RGB image. We could have also used 0, but RGB is more
        descriptive when we glance at the code. 
      </para>
      <para>
        You should also notice that we took the head of the result of
        the function call. This may seem strange, because the database
        explicitly tells us that it returns only one value -- the ID
        of the newly created image. However, all Gimp functions return
        a list, even if there is only one element in the list, so we
        need to get the head of the list. 
      </para>
    </simplesect>

    <simplesect>
      <title lang='en'>Adding A New Layer To The Image</title>
      <para lang='en'>
        Now that we have an image, we need to add a layer to it. We'll
        call the <code>gimp-layer-new</code> function to create the
        layer, passing 
        in the ID of the image we just created. (From now on, instead
        of listing the complete function, we'll only list the lines
        we're adding to it. You can see the complete script here.)
        Because we've declared all of the local variables we'll use,
        we'll also close the parentheses marking the end of our
        variable declarations: 
      </para>
      <programlisting>
        ;create a new layer for the image:
           (theLayer 
                     (car
                          (gimp-layer-new
                           theImage
                           theImageWidth
                           theImageHeight
                           RGB-IMAGE
                           "layer 1"
                           100
                           NORMAL
                          )
                      )
            )
         ) ;end of our local variables
      </programlisting>
      <para>
        Once we have the new layer, we need to add it to the image:
      </para>
     <programlisting>
       (gimp-image-add-layer theImage theLayer 0)
      </programlisting>
      <para>
        Now, just for fun, let's see the fruits of our labors up until
        this point, and add this line to show the new, empty image: 
      </para>
      <programlisting>
        (gimp-display-new theImage)
      </programlisting>
      <para>
       Save your work, select 
       <menuchoice>
         <guimenu>Xtns</guimenu>
         <guisubmenu>Script-Fu</guisubmenu>
         <guimenuitem>Refresh</guimenuitem>
       </menuchoice>, 
       run the script and a new image should pop up. It will probably
       contain garbage (random colors), because we haven't erased
       it. We'll get to that in a second. 
      </para>
    </simplesect>

    <simplesect>
      <title lang='en'>Adding The Text</title>
      <para lang='en'>
        Go ahead and remove the line to display the image (or comment
        it out with a ; as the first character of the line). 
      </para>
      <para>
        Before we add text to the image, we need to set the background
        and foreground colors so that the text appears in the color
        the user specified. We'll use the
        gimp-context-set-back/foreground functions: 
      </para>
      <programlisting>
        (gimp-context-set-background '(255 255 255) )
        (gimp-context-set-foreground inTextColor)
      </programlisting>
      <para>
        With the colors properly set, let's now clean out the garbage
        currently in the image by filling the drawable with the background
        color:
      </para>
      <programlisting>
        (gimp-drawable-fill theLayer BACKGROUND-FILL) 
      </programlisting>
      <para>
        With the image cleared, we're ready to add some text:
      </para>
      <programlisting>
        (set! theText
                      (car
                           (gimp-text-fontname
                            theImage theLayer
                            0 0
                            inText
                            0
                            TRUE
                            inFontSize PIXELS
                            "Sans")
                       )
        )  
      </programlisting>
      <para>
        Although a long function call, it's fairly straightforward if
        you go over the parameters while looking at the function's
        entry in the DB Browser. Basically, we're creating a new text
        layer and assigning it to the variable
        <varname>theText</varname>.  
      </para>
      <para>
        Now that we have the text, we can grab its width and height
        and resize the image and the image's layer to the text's size: 
      </para>
      <programlisting>
        (set! theImageWidth   (car (gimp-drawable-width  theText) ) )  	
        (set! theImageHeight  (car (gimp-drawable-height theText) ) )

        (gimp-image-resize theImage theImageWidth theImageHeight 0 0)	
  	
        (gimp-layer-resize theLayer theImageWidth theImageHeight 0 0)
      </programlisting>
      <para>
        If you're like me, you're probably wondering what a drawable
        is when compared to a layer. The difference between the two is
        that a drawable is anything that can be drawn into, including
        layers but also channels, layer masks, the selection, etc; a
        layer is 
        a more specific version of a drawable. In most cases, the
        distinction is not important. 
      </para>
      <para>
       With the image ready to go, we can now re-add our display line:
      </para>
      <programlisting>
        (gimp-display-new theImage)
      </programlisting>
      <para>
        Save your work, refresh the database and give your first
        script a run!
      </para>
    </simplesect>

    <simplesect>
      <title lang='en'>Clearing The Dirty Flag</title>
      <para lang='en'>
        If you try to close the image created without first saving the
        file, Gimp will ask you if you want to save your work before
        you close the image. It asks this because the image is marked
        as dirty, or unsaved. In the case of our script, this is a
        nuisance for the times when we simply give it a test run and
        don't add or change anything in the resulting image -- that
        is, our work is easily reproducible in such a simple script,
        so it makes sense to get rid of this dirty flag. 
      </para>
      <para>
        To do this, we can clear the dirty flag after displaying the
        image: 
      </para>
      <programlisting>
        (gimp-image-clean-all theImage)
      </programlisting>
      <para>
        This will set dirty count to 0, making it appear to be a
        "clean" image. 
      </para>
      <para>
        Whether to add this line or not is a matter of personal
        taste. I use it in scripts that produce new images, where the
        results are trivial, as in this case. If your script is very
        complicated, or if it works on an existing image, you will
        probably not want to use this function. 
      </para>
    </simplesect>
  </sect2>

  <sect2>
    <title lang='en'>Extending The Text Box Script</title>
    <simplesect>
      <title lang='en'>Handling Undo Correctly</title>
      <para>
        When creating a script, you want to give your users the
        ability to undo their actions, should they make a
        mistake. This is easily accomplished by calling the functions
        <code>gimp-undo-push-group-start</code> and 
        <code>gimp-undo-push-group-end</code> around
        the code that manipulates the image. You can think of them as
        matched statements that let Gimp know when to start and stop
        recording manipulations on the image, so that those
        manipulations can later be undone. 
      </para>
      <para>
        If you are creating a new image entirely, it doesn't make
        sense to use these functions because you're not changing an
        existing image. However, when you are changing an existing
        image, you most surely want to use these functions. 
      </para>
      <para>
        Undoing a script works nearly flawlessly when using these
        functions. 
      </para>
    </simplesect>

    <simplesect>
      <title lang='en'>Extending The Script A Little More</title>
      <para lang='en'>
        Now that we have a very handy-dandy script to create text
        boxes, let's add two features to it: 
      </para>
      <itemizedlist lang='en'>
        <listitem><para>
          Currently, the image is resized to fit exactly around the
          text -- there's no room for anything, like drop shadows or
          special effects (even though many scripts will automatically
          resize the image as necessary). Let's add a buffer around
          the text, and even let the user specify how much buffer to
          add as a percentage of the size of the resultant text. 
        </para></listitem>
        <listitem><para>
          This script could easily be used in other scripts that work
          with text. Let's extend it so that it returns the image and
          the layers, so other scripts can call this script and use
          the image and layers we create. 
        </para></listitem>
      </itemizedlist>
    </simplesect>

    <simplesect>
      <title lang='en'>Modifying The Parameters And The Registration Function</title>
      <para lang='en'>
        To let the user specify the amount of buffer, we'll add a
        parameter to our function and the registration function: 
      </para>
      <programlisting>
        (define (script-fu-text-box inTest inFont inFontSize inTextColor inBufferAmount)
        (let*
              (
                 ; define our local variables
                 ; create a new image:
                 (theImageWidth  10)
                 (theImageHeight 10)
                 (theImage (car 
                                (gimp-image-new
                                 theImageWidth
                                 theImageHeight
                                 RGB
                                )
                           )
                 )
                 (theText)          ;a declaration for the text
                                    ;we create later

                 (theBuffer)        ;<emphasis role='bold'>added</emphasis>
                 (theLayer 
                           (car
                               (gimp-layer-new
                                theImage
                                theImageWidth
                                theImageHeight
                                RGB-IMAGE
                                "layer 1"
                                100
                                NORMAL
                               )
                           )
                 )
              ) ;end of our local variables

         <replaceable>[Code here]</replaceable>
       )
      </programlisting>
      <programlisting>
<![CDATA[
        (script-fu-register
          "script-fu-text-box"                        ;func name
          "Text Box"                                  ;menu label
          "Creates a simple text box, sized to fit\
            around the user's choice of text,\
            font, font size, and color."              ;description
          "Michael Terry"                             ;author
          "copyright 1997, Michael Terry"             ;copyright notice
          "October 27, 1997"                          ;date created
          ""                     ;image type that the script works on
          SF-STRING      "Text:"         "Text Box"   ;a string variable
          SF-FONT        "Font:"         "Charter"    ;a font variable
          SF-ADJUSTMENT  "Font size"     '(50 1 1000 1 10 0 1)
                                                      ;a spin-button
          SF-COLOR       "Color:"        '(0 0 0)     ;color variable
          SF-ADJUSTMENT  "Buffer amount" '(35 0 100 1 10 1 0)
                                                      ;a slider
        )
        (script-fu-menu-register "script-fu-text-box" "<Toolbox>/Xtns/Script-Fu/Text")
]]>
      </programlisting>
    </simplesect>

    <simplesect>
      <title lang='en'>Adding The New Code</title>
      <para lang='en'>
        We're going to add code in two places: right before we resize
        the image, and at the end of the script (to return the new
        image, the layer and the text). 
      </para>
      <para>
        After we get the text's height and width, we need to resize
        these values based on the buffer amount specified by the
        user. We won't do any error checking to make sure it's in the
        range of 0-100% because it's not life-threatening, and because
        there's no reason why the user can't enter a value like "200"
        as the percent of buffer to add. 
      </para>
      <programlisting>
        (set! theBuffer (* theImageHeight (/ inBufferAmount 100) ) )

        (set! theImageHeight (+ theImageHeight theBuffer theBuffer) )
        (set! theImageWidth  (+ theImageWidth  theBuffer theBuffer) ) 	
      </programlisting>
      <para>
        All we're doing here is setting the buffer based on the height
        of the text, and adding it twice to both the height and width
        of our new image. (We add it twice to both dimensions because
        the buffer needs to be added to both sides of the text.) 
      </para>
      <para>
        Now that we have resized the image to allow for a buffer, we
        need to center the text within the image. This is done by
        moving it to the (x, y) coordinates of (<varname>theBuffer</varname>,
        <varname>theBuffer</varname>). I added this line after
        resizing the layer and the image: 
      </para>
      <programlisting>
        (gimp-layer-set-offsets theText theBuffer theBuffer)
      </programlisting>
      <para>
        Go ahead and save your script, and try it out after refreshing
        the database.
      </para>
      <para>
  	All that is left to do is return our image, the layer, and the
  	text layer. After displaying the image, we add this line: 
      </para>
      <programlisting>
        (list theImage theLayer theText)
      </programlisting>
      <para>
        This is the last line of the function, making this list
        available to other scripts that want to use it.
      </para>
      <para>
        To use our new text box script in another script, we could
        write something like the following: 
      </para>
      <programlisting>
        (set! theResult (script-fu-text-box 
                         "Some text" 
                         "Charter" "30"
                         '(0 0 0)
                         "35"
                        )
        )
        (gimp-image-flatten (car theResult))   	
      </programlisting>
      <para>
        Congratulations, you are on your way to your Black Belt of Script-Fu!
      </para>
    </simplesect>
  </sect2>
</sect1>
